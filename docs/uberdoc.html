<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="Expose your Clojure functions on the web easily" name="description" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{display:inline;font-size:34px;}h2.project-version{display:inline;margin-left:10px;margin-top:0;font-size:18px;}.toc-link{margin-left:10px;color:#252519;font-size:12px;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{margin:0;font-size:34px;}.docs-header{margin-bottom:25px;padding-bottom:10px;border-bottom:dotted #aaa 1px;}.toc h1{font-size:24px;}.toc{margin-bottom:40px;border-bottom:solid #bbb 1px;}.toc ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.toc li{padding-left:0;list-style-type:none;}.dependencies{}.dependencies table{border:none;width:99.99%;margin-left:20px;font-size:16px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{margin-bottom:-6px;noshade:noshade;border-top:none;color:transparent;border-left:none;border-bottom:dotted #bbb 1px;border-right:none;background-color:transparent;height:0;}.dependencies .dep-version{text-align:right;}.plugins ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.plugins li{padding-left:0;list-style-type:none;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;text-align:right;overflow:hidden;top:10px;right:20px;height:20px;}#floating-toc li{margin:0;padding:0;list-style-type:none;}</style><style type="text/css">body{margin:0;padding:0;color:#252519;font-size:16px;background-color:#F5F5FF;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;}h1{margin-top:0;font-size:20px;}a.anchor{color:#252519;text-decoration:none;}a.anchor:hover{color:#5050A6;}table{margin-bottom:10px;border-bottom:solid #ddd 1px;;border-spacing:0;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{border:none;margin:0px;padding-left:55px;width:410px;padding-right:20px;vertical-align:top;max-width:410px;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{border:none;margin:0px;padding-left:20px;width:55%;border-left:solid #E5E5EE 1px;font-size:10pt;vertical-align:top;overflow:hidden;background-color:#F5F5FF;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;background-color:ghostWhite;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*!
 * jQuery JavaScript Library v1.4.4
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Nov 11 19:04:53 2010 -0500
 */
(function(E,B){function ka(a,b,d){if(d===B&&a.nodeType===1){d=a.getAttribute("data-"+b);if(typeof d==="string"){try{d=d==="true"?true:d==="false"?false:d==="null"?null:!c.isNaN(d)?parseFloat(d):Ja.test(d)?c.parseJSON(d):d}catch(e){}c.data(a,b,d)}else d=B}return d}function U(){return false}function ca(){return true}function la(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function Ka(a){var b,d,e,f,h,l,k,o,x,r,A,C=[];f=[];h=c.data(this,this.nodeType?"events":"__events__");if(typeof h==="function")h=
h.events;if(!(a.liveFired===this||!h||!h.live||a.button&&a.type==="click")){if(a.namespace)A=RegExp("(^|\\.)"+a.namespace.split(".").join("\\.(?:.*\\.)?")+"(\\.|$)");a.liveFired=this;var J=h.live.slice(0);for(k=0;k<J.length;k++){h=J[k];h.origType.replace(X,"")===a.type?f.push(h.selector):J.splice(k--,1)}f=c(a.target).closest(f,a.currentTarget);o=0;for(x=f.length;o<x;o++){r=f[o];for(k=0;k<J.length;k++){h=J[k];if(r.selector===h.selector&&(!A||A.test(h.namespace))){l=r.elem;e=null;if(h.preType==="mouseenter"||
h.preType==="mouseleave"){a.type=h.preType;e=c(a.relatedTarget).closest(h.selector)[0]}if(!e||e!==l)C.push({elem:l,handleObj:h,level:r.level})}}}o=0;for(x=C.length;o<x;o++){f=C[o];if(d&&f.level>d)break;a.currentTarget=f.elem;a.data=f.handleObj.data;a.handleObj=f.handleObj;A=f.handleObj.origHandler.apply(f.elem,arguments);if(A===false||a.isPropagationStopped()){d=f.level;if(A===false)b=false;if(a.isImmediatePropagationStopped())break}}return b}}function Y(a,b){return(a&&a!=="*"?a+".":"")+b.replace(La,
"`").replace(Ma,"&")}function ma(a,b,d){if(c.isFunction(b))return c.grep(a,function(f,h){return!!b.call(f,h,f)===d});else if(b.nodeType)return c.grep(a,function(f){return f===b===d});else if(typeof b==="string"){var e=c.grep(a,function(f){return f.nodeType===1});if(Na.test(b))return c.filter(b,e,!d);else b=c.filter(b,e)}return c.grep(a,function(f){return c.inArray(f,b)>=0===d})}function na(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var e=c.data(a[d++]),f=c.data(this,
e);if(e=e&&e.events){delete f.handle;f.events={};for(var h in e)for(var l in e[h])c.event.add(this,h,e[h][l],e[h][l].data)}}})}function Oa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function oa(a,b,d){var e=b==="width"?a.offsetWidth:a.offsetHeight;if(d==="border")return e;c.each(b==="width"?Pa:Qa,function(){d||(e-=parseFloat(c.css(a,"padding"+this))||0);if(d==="margin")e+=parseFloat(c.css(a,
"margin"+this))||0;else e-=parseFloat(c.css(a,"border"+this+"Width"))||0});return e}function da(a,b,d,e){if(c.isArray(b)&&b.length)c.each(b,function(f,h){d||Ra.test(a)?e(a,h):da(a+"["+(typeof h==="object"||c.isArray(h)?f:"")+"]",h,d,e)});else if(!d&&b!=null&&typeof b==="object")c.isEmptyObject(b)?e(a,""):c.each(b,function(f,h){da(a+"["+f+"]",h,d,e)});else e(a,b)}function S(a,b){var d={};c.each(pa.concat.apply([],pa.slice(0,b)),function(){d[this]=a});return d}function qa(a){if(!ea[a]){var b=c("<"+
a+">").appendTo("body"),d=b.css("display");b.remove();if(d==="none"||d==="")d="block";ea[a]=d}return ea[a]}function fa(a){return c.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var t=E.document,c=function(){function a(){if(!b.isReady){try{t.documentElement.doScroll("left")}catch(j){setTimeout(a,1);return}b.ready()}}var b=function(j,s){return new b.fn.init(j,s)},d=E.jQuery,e=E.$,f,h=/^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,l=/\S/,k=/^\s+/,o=/\s+$/,x=/\W/,r=/\d/,A=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,
C=/^[\],:{}\s]*$/,J=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,w=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,I=/(?:^|:|,)(?:\s*\[)+/g,L=/(webkit)[ \/]([\w.]+)/,g=/(opera)(?:.*version)?[ \/]([\w.]+)/,i=/(msie) ([\w.]+)/,n=/(mozilla)(?:.*? rv:([\w.]+))?/,m=navigator.userAgent,p=false,q=[],u,y=Object.prototype.toString,F=Object.prototype.hasOwnProperty,M=Array.prototype.push,N=Array.prototype.slice,O=String.prototype.trim,D=Array.prototype.indexOf,R={};b.fn=b.prototype={init:function(j,
s){var v,z,H;if(!j)return this;if(j.nodeType){this.context=this[0]=j;this.length=1;return this}if(j==="body"&&!s&&t.body){this.context=t;this[0]=t.body;this.selector="body";this.length=1;return this}if(typeof j==="string")if((v=h.exec(j))&&(v[1]||!s))if(v[1]){H=s?s.ownerDocument||s:t;if(z=A.exec(j))if(b.isPlainObject(s)){j=[t.createElement(z[1])];b.fn.attr.call(j,s,true)}else j=[H.createElement(z[1])];else{z=b.buildFragment([v[1]],[H]);j=(z.cacheable?z.fragment.cloneNode(true):z.fragment).childNodes}return b.merge(this,
j)}else{if((z=t.getElementById(v[2]))&&z.parentNode){if(z.id!==v[2])return f.find(j);this.length=1;this[0]=z}this.context=t;this.selector=j;return this}else if(!s&&!x.test(j)){this.selector=j;this.context=t;j=t.getElementsByTagName(j);return b.merge(this,j)}else return!s||s.jquery?(s||f).find(j):b(s).find(j);else if(b.isFunction(j))return f.ready(j);if(j.selector!==B){this.selector=j.selector;this.context=j.context}return b.makeArray(j,this)},selector:"",jquery:"1.4.4",length:0,size:function(){return this.length},
toArray:function(){return N.call(this,0)},get:function(j){return j==null?this.toArray():j<0?this.slice(j)[0]:this[j]},pushStack:function(j,s,v){var z=b();b.isArray(j)?M.apply(z,j):b.merge(z,j);z.prevObject=this;z.context=this.context;if(s==="find")z.selector=this.selector+(this.selector?" ":"")+v;else if(s)z.selector=this.selector+"."+s+"("+v+")";return z},each:function(j,s){return b.each(this,j,s)},ready:function(j){b.bindReady();if(b.isReady)j.call(t,b);else q&&q.push(j);return this},eq:function(j){return j===
-1?this.slice(j):this.slice(j,+j+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(N.apply(this,arguments),"slice",N.call(arguments).join(","))},map:function(j){return this.pushStack(b.map(this,function(s,v){return j.call(s,v,s)}))},end:function(){return this.prevObject||b(null)},push:M,sort:[].sort,splice:[].splice};b.fn.init.prototype=b.fn;b.extend=b.fn.extend=function(){var j,s,v,z,H,G=arguments[0]||{},K=1,Q=arguments.length,ga=false;
if(typeof G==="boolean"){ga=G;G=arguments[1]||{};K=2}if(typeof G!=="object"&&!b.isFunction(G))G={};if(Q===K){G=this;--K}for(;K<Q;K++)if((j=arguments[K])!=null)for(s in j){v=G[s];z=j[s];if(G!==z)if(ga&&z&&(b.isPlainObject(z)||(H=b.isArray(z)))){if(H){H=false;v=v&&b.isArray(v)?v:[]}else v=v&&b.isPlainObject(v)?v:{};G[s]=b.extend(ga,v,z)}else if(z!==B)G[s]=z}return G};b.extend({noConflict:function(j){E.$=e;if(j)E.jQuery=d;return b},isReady:false,readyWait:1,ready:function(j){j===true&&b.readyWait--;
if(!b.readyWait||j!==true&&!b.isReady){if(!t.body)return setTimeout(b.ready,1);b.isReady=true;if(!(j!==true&&--b.readyWait>0))if(q){var s=0,v=q;for(q=null;j=v[s++];)j.call(t,b);b.fn.trigger&&b(t).trigger("ready").unbind("ready")}}},bindReady:function(){if(!p){p=true;if(t.readyState==="complete")return setTimeout(b.ready,1);if(t.addEventListener){t.addEventListener("DOMContentLoaded",u,false);E.addEventListener("load",b.ready,false)}else if(t.attachEvent){t.attachEvent("onreadystatechange",u);E.attachEvent("onload",
b.ready);var j=false;try{j=E.frameElement==null}catch(s){}t.documentElement.doScroll&&j&&a()}}},isFunction:function(j){return b.type(j)==="function"},isArray:Array.isArray||function(j){return b.type(j)==="array"},isWindow:function(j){return j&&typeof j==="object"&&"setInterval"in j},isNaN:function(j){return j==null||!r.test(j)||isNaN(j)},type:function(j){return j==null?String(j):R[y.call(j)]||"object"},isPlainObject:function(j){if(!j||b.type(j)!=="object"||j.nodeType||b.isWindow(j))return false;if(j.constructor&&
!F.call(j,"constructor")&&!F.call(j.constructor.prototype,"isPrototypeOf"))return false;for(var s in j);return s===B||F.call(j,s)},isEmptyObject:function(j){for(var s in j)return false;return true},error:function(j){throw j;},parseJSON:function(j){if(typeof j!=="string"||!j)return null;j=b.trim(j);if(C.test(j.replace(J,"@").replace(w,"]").replace(I,"")))return E.JSON&&E.JSON.parse?E.JSON.parse(j):(new Function("return "+j))();else b.error("Invalid JSON: "+j)},noop:function(){},globalEval:function(j){if(j&&
l.test(j)){var s=t.getElementsByTagName("head")[0]||t.documentElement,v=t.createElement("script");v.type="text/javascript";if(b.support.scriptEval)v.appendChild(t.createTextNode(j));else v.text=j;s.insertBefore(v,s.firstChild);s.removeChild(v)}},nodeName:function(j,s){return j.nodeName&&j.nodeName.toUpperCase()===s.toUpperCase()},each:function(j,s,v){var z,H=0,G=j.length,K=G===B||b.isFunction(j);if(v)if(K)for(z in j){if(s.apply(j[z],v)===false)break}else for(;H<G;){if(s.apply(j[H++],v)===false)break}else if(K)for(z in j){if(s.call(j[z],
z,j[z])===false)break}else for(v=j[0];H<G&&s.call(v,H,v)!==false;v=j[++H]);return j},trim:O?function(j){return j==null?"":O.call(j)}:function(j){return j==null?"":j.toString().replace(k,"").replace(o,"")},makeArray:function(j,s){var v=s||[];if(j!=null){var z=b.type(j);j.length==null||z==="string"||z==="function"||z==="regexp"||b.isWindow(j)?M.call(v,j):b.merge(v,j)}return v},inArray:function(j,s){if(s.indexOf)return s.indexOf(j);for(var v=0,z=s.length;v<z;v++)if(s[v]===j)return v;return-1},merge:function(j,
s){var v=j.length,z=0;if(typeof s.length==="number")for(var H=s.length;z<H;z++)j[v++]=s[z];else for(;s[z]!==B;)j[v++]=s[z++];j.length=v;return j},grep:function(j,s,v){var z=[],H;v=!!v;for(var G=0,K=j.length;G<K;G++){H=!!s(j[G],G);v!==H&&z.push(j[G])}return z},map:function(j,s,v){for(var z=[],H,G=0,K=j.length;G<K;G++){H=s(j[G],G,v);if(H!=null)z[z.length]=H}return z.concat.apply([],z)},guid:1,proxy:function(j,s,v){if(arguments.length===2)if(typeof s==="string"){v=j;j=v[s];s=B}else if(s&&!b.isFunction(s)){v=
s;s=B}if(!s&&j)s=function(){return j.apply(v||this,arguments)};if(j)s.guid=j.guid=j.guid||s.guid||b.guid++;return s},access:function(j,s,v,z,H,G){var K=j.length;if(typeof s==="object"){for(var Q in s)b.access(j,Q,s[Q],z,H,v);return j}if(v!==B){z=!G&&z&&b.isFunction(v);for(Q=0;Q<K;Q++)H(j[Q],s,z?v.call(j[Q],Q,H(j[Q],s)):v,G);return j}return K?H(j[0],s):B},now:function(){return(new Date).getTime()},uaMatch:function(j){j=j.toLowerCase();j=L.exec(j)||g.exec(j)||i.exec(j)||j.indexOf("compatible")<0&&n.exec(j)||
[];return{browser:j[1]||"",version:j[2]||"0"}},browser:{}});b.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(j,s){R["[object "+s+"]"]=s.toLowerCase()});m=b.uaMatch(m);if(m.browser){b.browser[m.browser]=true;b.browser.version=m.version}if(b.browser.webkit)b.browser.safari=true;if(D)b.inArray=function(j,s){return D.call(s,j)};if(!/\s/.test("\u00a0")){k=/^[\s\xA0]+/;o=/[\s\xA0]+$/}f=b(t);if(t.addEventListener)u=function(){t.removeEventListener("DOMContentLoaded",u,
false);b.ready()};else if(t.attachEvent)u=function(){if(t.readyState==="complete"){t.detachEvent("onreadystatechange",u);b.ready()}};return E.jQuery=E.$=b}();(function(){c.support={};var a=t.documentElement,b=t.createElement("script"),d=t.createElement("div"),e="script"+c.now();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";var f=d.getElementsByTagName("*"),h=d.getElementsByTagName("a")[0],l=t.createElement("select"),
k=l.appendChild(t.createElement("option"));if(!(!f||!f.length||!h)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(h.getAttribute("style")),hrefNormalized:h.getAttribute("href")==="/a",opacity:/^0.55$/.test(h.style.opacity),cssFloat:!!h.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:k.selected,deleteExpando:true,optDisabled:false,checkClone:false,
scriptEval:false,noCloneEvent:true,boxModel:null,inlineBlockNeedsLayout:false,shrinkWrapBlocks:false,reliableHiddenOffsets:true};l.disabled=true;c.support.optDisabled=!k.disabled;b.type="text/javascript";try{b.appendChild(t.createTextNode("window."+e+"=1;"))}catch(o){}a.insertBefore(b,a.firstChild);if(E[e]){c.support.scriptEval=true;delete E[e]}try{delete b.test}catch(x){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function r(){c.support.noCloneEvent=
false;d.detachEvent("onclick",r)});d.cloneNode(true).fireEvent("onclick")}d=t.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=t.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var r=t.createElement("div");r.style.width=r.style.paddingLeft="1px";t.body.appendChild(r);c.boxModel=c.support.boxModel=r.offsetWidth===2;if("zoom"in r.style){r.style.display="inline";r.style.zoom=
1;c.support.inlineBlockNeedsLayout=r.offsetWidth===2;r.style.display="";r.innerHTML="<div style='width:4px;'></div>";c.support.shrinkWrapBlocks=r.offsetWidth!==2}r.innerHTML="<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";var A=r.getElementsByTagName("td");c.support.reliableHiddenOffsets=A[0].offsetHeight===0;A[0].style.display="";A[1].style.display="none";c.support.reliableHiddenOffsets=c.support.reliableHiddenOffsets&&A[0].offsetHeight===0;r.innerHTML="";t.body.removeChild(r).style.display=
"none"});a=function(r){var A=t.createElement("div");r="on"+r;var C=r in A;if(!C){A.setAttribute(r,"return;");C=typeof A[r]==="function"}return C};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=f=h=null}})();var ra={},Ja=/^(?:\{.*\}|\[.*\])$/;c.extend({cache:{},uuid:0,expando:"jQuery"+c.now(),noData:{embed:true,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:true},data:function(a,b,d){if(c.acceptData(a)){a=a==E?ra:a;var e=a.nodeType,f=e?a[c.expando]:null,h=
c.cache;if(!(e&&!f&&typeof b==="string"&&d===B)){if(e)f||(a[c.expando]=f=++c.uuid);else h=a;if(typeof b==="object")if(e)h[f]=c.extend(h[f],b);else c.extend(h,b);else if(e&&!h[f])h[f]={};a=e?h[f]:h;if(d!==B)a[b]=d;return typeof b==="string"?a[b]:a}}},removeData:function(a,b){if(c.acceptData(a)){a=a==E?ra:a;var d=a.nodeType,e=d?a[c.expando]:a,f=c.cache,h=d?f[e]:e;if(b){if(h){delete h[b];d&&c.isEmptyObject(h)&&c.removeData(a)}}else if(d&&c.support.deleteExpando)delete a[c.expando];else if(a.removeAttribute)a.removeAttribute(c.expando);
else if(d)delete f[e];else for(var l in a)delete a[l]}},acceptData:function(a){if(a.nodeName){var b=c.noData[a.nodeName.toLowerCase()];if(b)return!(b===true||a.getAttribute("classid")!==b)}return true}});c.fn.extend({data:function(a,b){var d=null;if(typeof a==="undefined"){if(this.length){var e=this[0].attributes,f;d=c.data(this[0]);for(var h=0,l=e.length;h<l;h++){f=e[h].name;if(f.indexOf("data-")===0){f=f.substr(5);ka(this[0],f,d[f])}}}return d}else if(typeof a==="object")return this.each(function(){c.data(this,
a)});var k=a.split(".");k[1]=k[1]?"."+k[1]:"";if(b===B){d=this.triggerHandler("getData"+k[1]+"!",[k[0]]);if(d===B&&this.length){d=c.data(this[0],a);d=ka(this[0],a,d)}return d===B&&k[1]?this.data(k[0]):d}else return this.each(function(){var o=c(this),x=[k[0],b];o.triggerHandler("setData"+k[1]+"!",x);c.data(this,a,b);o.triggerHandler("changeData"+k[1]+"!",x)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var e=
c.data(a,b);if(!d)return e||[];if(!e||c.isArray(d))e=c.data(a,b,c.makeArray(d));else e.push(d);return e}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),e=d.shift();if(e==="inprogress")e=d.shift();if(e){b==="fx"&&d.unshift("inprogress");e.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===B)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,
a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var sa=/[\n\t]/g,ha=/\s+/,Sa=/\r/g,Ta=/^(?:href|src|style)$/,Ua=/^(?:button|input)$/i,Va=/^(?:button|input|object|select|textarea)$/i,Wa=/^a(?:rea)?$/i,ta=/^(?:radio|checkbox)$/i;c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",
colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};c.fn.extend({attr:function(a,b){return c.access(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(x){var r=c(this);r.addClass(a.call(this,x,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===
1)if(f.className){for(var h=" "+f.className+" ",l=f.className,k=0,o=b.length;k<o;k++)if(h.indexOf(" "+b[k]+" ")<0)l+=" "+b[k];f.className=c.trim(l)}else f.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(o){var x=c(this);x.removeClass(a.call(this,o,x.attr("class")))});if(a&&typeof a==="string"||a===B)for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===1&&f.className)if(a){for(var h=(" "+f.className+" ").replace(sa," "),
l=0,k=b.length;l<k;l++)h=h.replace(" "+b[l]+" "," ");f.className=c.trim(h)}else f.className=""}return this},toggleClass:function(a,b){var d=typeof a,e=typeof b==="boolean";if(c.isFunction(a))return this.each(function(f){var h=c(this);h.toggleClass(a.call(this,f,h.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var f,h=0,l=c(this),k=b,o=a.split(ha);f=o[h++];){k=e?k:!l.hasClass(f);l[k?"addClass":"removeClass"](f)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,
"__className__",this.className);this.className=this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(sa," ").indexOf(a)>-1)return true;return false},val:function(a){if(!arguments.length){var b=this[0];if(b){if(c.nodeName(b,"option")){var d=b.attributes.value;return!d||d.specified?b.value:b.text}if(c.nodeName(b,"select")){var e=b.selectedIndex;d=[];var f=b.options;b=b.type==="select-one";
if(e<0)return null;var h=b?e:0;for(e=b?e+1:f.length;h<e;h++){var l=f[h];if(l.selected&&(c.support.optDisabled?!l.disabled:l.getAttribute("disabled")===null)&&(!l.parentNode.disabled||!c.nodeName(l.parentNode,"optgroup"))){a=c(l).val();if(b)return a;d.push(a)}}return d}if(ta.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Sa,"")}return B}var k=c.isFunction(a);return this.each(function(o){var x=c(this),r=a;if(this.nodeType===1){if(k)r=
a.call(this,o,x.val());if(r==null)r="";else if(typeof r==="number")r+="";else if(c.isArray(r))r=c.map(r,function(C){return C==null?"":C+""});if(c.isArray(r)&&ta.test(this.type))this.checked=c.inArray(x.val(),r)>=0;else if(c.nodeName(this,"select")){var A=c.makeArray(r);c("option",this).each(function(){this.selected=c.inArray(c(this).val(),A)>=0});if(!A.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},
attr:function(a,b,d,e){if(!a||a.nodeType===3||a.nodeType===8)return B;if(e&&b in c.attrFn)return c(a)[b](d);e=a.nodeType!==1||!c.isXMLDoc(a);var f=d!==B;b=e&&c.props[b]||b;var h=Ta.test(b);if((b in a||a[b]!==B)&&e&&!h){if(f){b==="type"&&Ua.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");if(d===null)a.nodeType===1&&a.removeAttribute(b);else a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&
b.specified?b.value:Va.test(a.nodeName)||Wa.test(a.nodeName)&&a.href?0:B;return a[b]}if(!c.support.style&&e&&b==="style"){if(f)a.style.cssText=""+d;return a.style.cssText}f&&a.setAttribute(b,""+d);if(!a.attributes[b]&&a.hasAttribute&&!a.hasAttribute(b))return B;a=!c.support.hrefNormalized&&e&&h?a.getAttribute(b,2):a.getAttribute(b);return a===null?B:a}});var X=/\.(.*)$/,ia=/^(?:textarea|input|select)$/i,La=/\./g,Ma=/ /g,Xa=/[^\w\s.|`]/g,Ya=function(a){return a.replace(Xa,"\\$&")},ua={focusin:0,focusout:0};
c.event={add:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(c.isWindow(a)&&a!==E&&!a.frameElement)a=E;if(d===false)d=U;else if(!d)return;var f,h;if(d.handler){f=d;d=f.handler}if(!d.guid)d.guid=c.guid++;if(h=c.data(a)){var l=a.nodeType?"events":"__events__",k=h[l],o=h.handle;if(typeof k==="function"){o=k.handle;k=k.events}else if(!k){a.nodeType||(h[l]=h=function(){});h.events=k={}}if(!o)h.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,
arguments):B};o.elem=a;b=b.split(" ");for(var x=0,r;l=b[x++];){h=f?c.extend({},f):{handler:d,data:e};if(l.indexOf(".")>-1){r=l.split(".");l=r.shift();h.namespace=r.slice(0).sort().join(".")}else{r=[];h.namespace=""}h.type=l;if(!h.guid)h.guid=d.guid;var A=k[l],C=c.event.special[l]||{};if(!A){A=k[l]=[];if(!C.setup||C.setup.call(a,e,r,o)===false)if(a.addEventListener)a.addEventListener(l,o,false);else a.attachEvent&&a.attachEvent("on"+l,o)}if(C.add){C.add.call(a,h);if(!h.handler.guid)h.handler.guid=
d.guid}A.push(h);c.event.global[l]=true}a=null}}},global:{},remove:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(d===false)d=U;var f,h,l=0,k,o,x,r,A,C,J=a.nodeType?"events":"__events__",w=c.data(a),I=w&&w[J];if(w&&I){if(typeof I==="function"){w=I;I=I.events}if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(f in I)c.event.remove(a,f+b)}else{for(b=b.split(" ");f=b[l++];){r=f;k=f.indexOf(".")<0;o=[];if(!k){o=f.split(".");f=o.shift();x=RegExp("(^|\\.)"+
c.map(o.slice(0).sort(),Ya).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(A=I[f])if(d){r=c.event.special[f]||{};for(h=e||0;h<A.length;h++){C=A[h];if(d.guid===C.guid){if(k||x.test(C.namespace)){e==null&&A.splice(h--,1);r.remove&&r.remove.call(a,C)}if(e!=null)break}}if(A.length===0||e!=null&&A.length===1){if(!r.teardown||r.teardown.call(a,o)===false)c.removeEvent(a,f,w.handle);delete I[f]}}else for(h=0;h<A.length;h++){C=A[h];if(k||x.test(C.namespace)){c.event.remove(a,r,C.handler,h);A.splice(h--,1)}}}if(c.isEmptyObject(I)){if(b=
w.handle)b.elem=null;delete w.events;delete w.handle;if(typeof w==="function")c.removeData(a,J);else c.isEmptyObject(w)&&c.removeData(a)}}}}},trigger:function(a,b,d,e){var f=a.type||a;if(!e){a=typeof a==="object"?a[c.expando]?a:c.extend(c.Event(f),a):c.Event(f);if(f.indexOf("!")>=0){a.type=f=f.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[f]&&c.each(c.cache,function(){this.events&&this.events[f]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===
8)return B;a.result=B;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(e=d.nodeType?c.data(d,"handle"):(c.data(d,"__events__")||{}).handle)&&e.apply(d,b);e=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+f]&&d["on"+f].apply(d,b)===false){a.result=false;a.preventDefault()}}catch(h){}if(!a.isPropagationStopped()&&e)c.event.trigger(a,b,e,true);else if(!a.isDefaultPrevented()){var l;e=a.target;var k=f.replace(X,""),o=c.nodeName(e,"a")&&k===
"click",x=c.event.special[k]||{};if((!x._default||x._default.call(d,a)===false)&&!o&&!(e&&e.nodeName&&c.noData[e.nodeName.toLowerCase()])){try{if(e[k]){if(l=e["on"+k])e["on"+k]=null;c.event.triggered=true;e[k]()}}catch(r){}if(l)e["on"+k]=l;c.event.triggered=false}}},handle:function(a){var b,d,e,f;d=[];var h=c.makeArray(arguments);a=h[0]=c.event.fix(a||E.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;if(!b){e=a.type.split(".");a.type=e.shift();d=e.slice(0).sort();e=RegExp("(^|\\.)"+
d.join("\\.(?:.*\\.)?")+"(\\.|$)")}a.namespace=a.namespace||d.join(".");f=c.data(this,this.nodeType?"events":"__events__");if(typeof f==="function")f=f.events;d=(f||{})[a.type];if(f&&d){d=d.slice(0);f=0;for(var l=d.length;f<l;f++){var k=d[f];if(b||e.test(k.namespace)){a.handler=k.handler;a.data=k.data;a.handleObj=k;k=k.handler.apply(this,h);if(k!==B){a.result=k;if(k===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[c.expando])return a;var b=a;a=c.Event(b);for(var d=this.props.length,e;d;){e=this.props[--d];a[e]=b[e]}if(!a.target)a.target=a.srcElement||t;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=t.documentElement;d=t.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(a.which==null&&(a.charCode!=null||a.keyCode!=null))a.which=a.charCode!=null?a.charCode:a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==B)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,Y(a.origType,a.selector),c.extend({},a,{handler:Ka,guid:a.handler.guid}))},remove:function(a){c.event.remove(this,
Y(a.origType,a.selector),a)}},beforeunload:{setup:function(a,b,d){if(c.isWindow(this))this.onbeforeunload=d},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};c.removeEvent=t.removeEventListener?function(a,b,d){a.removeEventListener&&a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent&&a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=
c.now();this[c.expando]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=ca;var a=this.originalEvent;if(a)if(a.preventDefault)a.preventDefault();else a.returnValue=false},stopPropagation:function(){this.isPropagationStopped=ca;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=ca;this.stopPropagation()},isDefaultPrevented:U,isPropagationStopped:U,isImmediatePropagationStopped:U};
var va=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},wa=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?wa:va,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?wa:va)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==
"form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length){a.liveFired=B;return la("submit",this,arguments)}});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13){a.liveFired=B;return la("submit",this,arguments)}})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};if(!c.support.changeBubbles){var V,
xa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(e){return e.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},Z=function(a,b){var d=a.target,e,f;if(!(!ia.test(d.nodeName)||d.readOnly)){e=c.data(d,"_change_data");f=xa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",f);if(!(e===B||f===e))if(e!=null||f){a.type="change";a.liveFired=
B;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:Z,beforedeactivate:Z,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return Z.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return Z.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,"_change_data",xa(a))}},setup:function(){if(this.type===
"file")return false;for(var a in V)c.event.add(this,a+".specialChange",V[a]);return ia.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return ia.test(this.nodeName)}};V=c.event.special.change.filters;V.focus=V.beforeactivate}t.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(e){e=c.event.fix(e);e.type=b;return c.event.trigger(e,null,e.target)}c.event.special[b]={setup:function(){ua[b]++===0&&t.addEventListener(a,d,true)},teardown:function(){--ua[b]===
0&&t.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,e,f){if(typeof d==="object"){for(var h in d)this[b](h,e,d[h],f);return this}if(c.isFunction(e)||e===false){f=e;e=B}var l=b==="one"?c.proxy(f,function(o){c(this).unbind(o,l);return f.apply(this,arguments)}):f;if(d==="unload"&&b!=="one")this.one(d,e,f);else{h=0;for(var k=this.length;h<k;h++)c.event.add(this[h],d,l,e)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&!a.preventDefault)for(var d in a)this.unbind(d,
a[d]);else{d=0;for(var e=this.length;d<e;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,e){return this.live(b,d,e,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){var d=c.Event(a);d.preventDefault();d.stopPropagation();c.event.trigger(d,b,this[0]);return d.result}},toggle:function(a){for(var b=arguments,d=
1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(e){var f=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,f+1);e.preventDefault();return b[f].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var ya={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,e,f,h){var l,k=0,o,x,r=h||this.selector;h=h?this:c(this.context);if(typeof d===
"object"&&!d.preventDefault){for(l in d)h[b](l,e,d[l],r);return this}if(c.isFunction(e)){f=e;e=B}for(d=(d||"").split(" ");(l=d[k++])!=null;){o=X.exec(l);x="";if(o){x=o[0];l=l.replace(X,"")}if(l==="hover")d.push("mouseenter"+x,"mouseleave"+x);else{o=l;if(l==="focus"||l==="blur"){d.push(ya[l]+x);l+=x}else l=(ya[l]||l)+x;if(b==="live"){x=0;for(var A=h.length;x<A;x++)c.event.add(h[x],"live."+Y(l,r),{data:e,selector:r,handler:f,origType:l,origHandler:f,preType:o})}else h.unbind("live."+Y(l,r),f)}}return this}});
c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(a,b){c.fn[b]=function(d,e){if(e==null){e=d;d=null}return arguments.length>0?this.bind(b,d,e):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});E.attachEvent&&!E.addEventListener&&c(E).bind("unload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});
(function(){function a(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1&&!q){y.sizcache=n;y.sizset=p}if(y.nodeName.toLowerCase()===i){F=y;break}y=y[g]}m[p]=F}}}function b(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1){if(!q){y.sizcache=n;y.sizset=p}if(typeof i!=="string"){if(y===i){F=true;break}}else if(k.filter(i,
[y]).length>0){F=y;break}}y=y[g]}m[p]=F}}}var d=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,f=Object.prototype.toString,h=false,l=true;[0,0].sort(function(){l=false;return 0});var k=function(g,i,n,m){n=n||[];var p=i=i||t;if(i.nodeType!==1&&i.nodeType!==9)return[];if(!g||typeof g!=="string")return n;var q,u,y,F,M,N=true,O=k.isXML(i),D=[],R=g;do{d.exec("");if(q=d.exec(R)){R=q[3];D.push(q[1]);if(q[2]){F=q[3];
break}}}while(q);if(D.length>1&&x.exec(g))if(D.length===2&&o.relative[D[0]])u=L(D[0]+D[1],i);else for(u=o.relative[D[0]]?[i]:k(D.shift(),i);D.length;){g=D.shift();if(o.relative[g])g+=D.shift();u=L(g,u)}else{if(!m&&D.length>1&&i.nodeType===9&&!O&&o.match.ID.test(D[0])&&!o.match.ID.test(D[D.length-1])){q=k.find(D.shift(),i,O);i=q.expr?k.filter(q.expr,q.set)[0]:q.set[0]}if(i){q=m?{expr:D.pop(),set:C(m)}:k.find(D.pop(),D.length===1&&(D[0]==="~"||D[0]==="+")&&i.parentNode?i.parentNode:i,O);u=q.expr?k.filter(q.expr,
q.set):q.set;if(D.length>0)y=C(u);else N=false;for(;D.length;){q=M=D.pop();if(o.relative[M])q=D.pop();else M="";if(q==null)q=i;o.relative[M](y,q,O)}}else y=[]}y||(y=u);y||k.error(M||g);if(f.call(y)==="[object Array]")if(N)if(i&&i.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&k.contains(i,y[g])))n.push(u[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&n.push(u[g]);else n.push.apply(n,y);else C(y,n);if(F){k(F,p,n,m);k.uniqueSort(n)}return n};k.uniqueSort=function(g){if(w){h=
l;g.sort(w);if(h)for(var i=1;i<g.length;i++)g[i]===g[i-1]&&g.splice(i--,1)}return g};k.matches=function(g,i){return k(g,null,null,i)};k.matchesSelector=function(g,i){return k(i,null,null,[g]).length>0};k.find=function(g,i,n){var m;if(!g)return[];for(var p=0,q=o.order.length;p<q;p++){var u,y=o.order[p];if(u=o.leftMatch[y].exec(g)){var F=u[1];u.splice(1,1);if(F.substr(F.length-1)!=="\\"){u[1]=(u[1]||"").replace(/\\/g,"");m=o.find[y](u,i,n);if(m!=null){g=g.replace(o.match[y],"");break}}}}m||(m=i.getElementsByTagName("*"));
return{set:m,expr:g}};k.filter=function(g,i,n,m){for(var p,q,u=g,y=[],F=i,M=i&&i[0]&&k.isXML(i[0]);g&&i.length;){for(var N in o.filter)if((p=o.leftMatch[N].exec(g))!=null&&p[2]){var O,D,R=o.filter[N];D=p[1];q=false;p.splice(1,1);if(D.substr(D.length-1)!=="\\"){if(F===y)y=[];if(o.preFilter[N])if(p=o.preFilter[N](p,F,n,y,m,M)){if(p===true)continue}else q=O=true;if(p)for(var j=0;(D=F[j])!=null;j++)if(D){O=R(D,p,j,F);var s=m^!!O;if(n&&O!=null)if(s)q=true;else F[j]=false;else if(s){y.push(D);q=true}}if(O!==
B){n||(F=y);g=g.replace(o.match[N],"");if(!q)return[];break}}}if(g===u)if(q==null)k.error(g);else break;u=g}return F};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var o=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},relative:{"+":function(g,i){var n=typeof i==="string",m=n&&!/\W/.test(i);n=n&&!m;if(m)i=i.toLowerCase();m=0;for(var p=g.length,q;m<p;m++)if(q=g[m]){for(;(q=q.previousSibling)&&q.nodeType!==1;);g[m]=n||q&&q.nodeName.toLowerCase()===
i?q||false:q===i}n&&k.filter(i,g,true)},">":function(g,i){var n,m=typeof i==="string",p=0,q=g.length;if(m&&!/\W/.test(i))for(i=i.toLowerCase();p<q;p++){if(n=g[p]){n=n.parentNode;g[p]=n.nodeName.toLowerCase()===i?n:false}}else{for(;p<q;p++)if(n=g[p])g[p]=m?n.parentNode:n.parentNode===i;m&&k.filter(i,g,true)}},"":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=i=i.toLowerCase();q=a}q("parentNode",i,p,g,m,n)},"~":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=
i=i.toLowerCase();q=a}q("previousSibling",i,p,g,m,n)}},find:{ID:function(g,i,n){if(typeof i.getElementById!=="undefined"&&!n)return(g=i.getElementById(g[1]))&&g.parentNode?[g]:[]},NAME:function(g,i){if(typeof i.getElementsByName!=="undefined"){for(var n=[],m=i.getElementsByName(g[1]),p=0,q=m.length;p<q;p++)m[p].getAttribute("name")===g[1]&&n.push(m[p]);return n.length===0?null:n}},TAG:function(g,i){return i.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,i,n,m,p,q){g=" "+g[1].replace(/\\/g,
"")+" ";if(q)return g;q=0;for(var u;(u=i[q])!=null;q++)if(u)if(p^(u.className&&(" "+u.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))n||m.push(u);else if(n)i[q]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]==="nth"){var i=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=i[1]+(i[2]||1)-0;g[3]=i[3]-0}g[0]=e++;return g},ATTR:function(g,i,n,
m,p,q){i=g[1].replace(/\\/g,"");if(!q&&o.attrMap[i])g[1]=o.attrMap[i];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,i,n,m,p){if(g[1]==="not")if((d.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,i);else{g=k.filter(g[3],i,n,true^p);n||m.push.apply(m,g);return false}else if(o.match.POS.test(g[0])||o.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===
true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,i,n){return!!k(n[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===
g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},setFilters:{first:function(g,i){return i===0},last:function(g,i,n,m){return i===m.length-1},even:function(g,i){return i%2===0},odd:function(g,i){return i%2===1},lt:function(g,i,n){return i<n[3]-0},gt:function(g,i,n){return i>n[3]-0},nth:function(g,i,n){return n[3]-
0===i},eq:function(g,i,n){return n[3]-0===i}},filter:{PSEUDO:function(g,i,n,m){var p=i[1],q=o.filters[p];if(q)return q(g,n,i,m);else if(p==="contains")return(g.textContent||g.innerText||k.getText([g])||"").indexOf(i[3])>=0;else if(p==="not"){i=i[3];n=0;for(m=i.length;n<m;n++)if(i[n]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+p)},CHILD:function(g,i){var n=i[1],m=g;switch(n){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(n===
"first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":n=i[2];var p=i[3];if(n===1&&p===0)return true;var q=i[0],u=g.parentNode;if(u&&(u.sizcache!==q||!g.nodeIndex)){var y=0;for(m=u.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++y;u.sizcache=q}m=g.nodeIndex-p;return n===0?m===0:m%n===0&&m/n>=0}},ID:function(g,i){return g.nodeType===1&&g.getAttribute("id")===i},TAG:function(g,i){return i==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===
i},CLASS:function(g,i){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(i)>-1},ATTR:function(g,i){var n=i[1];n=o.attrHandle[n]?o.attrHandle[n](g):g[n]!=null?g[n]:g.getAttribute(n);var m=n+"",p=i[2],q=i[4];return n==null?p==="!=":p==="="?m===q:p==="*="?m.indexOf(q)>=0:p==="~="?(" "+m+" ").indexOf(q)>=0:!q?m&&n!==false:p==="!="?m!==q:p==="^="?m.indexOf(q)===0:p==="$="?m.substr(m.length-q.length)===q:p==="|="?m===q||m.substr(0,q.length+1)===q+"-":false},POS:function(g,i,n,m){var p=o.setFilters[i[2]];
if(p)return p(g,n,i,m)}}},x=o.match.POS,r=function(g,i){return"\\"+(i-0+1)},A;for(A in o.match){o.match[A]=RegExp(o.match[A].source+/(?![^\[]*\])(?![^\(]*\))/.source);o.leftMatch[A]=RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[A].source.replace(/\\(\d+)/g,r))}var C=function(g,i){g=Array.prototype.slice.call(g,0);if(i){i.push.apply(i,g);return i}return g};try{Array.prototype.slice.call(t.documentElement.childNodes,0)}catch(J){C=function(g,i){var n=0,m=i||[];if(f.call(g)==="[object Array]")Array.prototype.push.apply(m,
g);else if(typeof g.length==="number")for(var p=g.length;n<p;n++)m.push(g[n]);else for(;g[n];n++)m.push(g[n]);return m}}var w,I;if(t.documentElement.compareDocumentPosition)w=function(g,i){if(g===i){h=true;return 0}if(!g.compareDocumentPosition||!i.compareDocumentPosition)return g.compareDocumentPosition?-1:1;return g.compareDocumentPosition(i)&4?-1:1};else{w=function(g,i){var n,m,p=[],q=[];n=g.parentNode;m=i.parentNode;var u=n;if(g===i){h=true;return 0}else if(n===m)return I(g,i);else if(n){if(!m)return 1}else return-1;
for(;u;){p.unshift(u);u=u.parentNode}for(u=m;u;){q.unshift(u);u=u.parentNode}n=p.length;m=q.length;for(u=0;u<n&&u<m;u++)if(p[u]!==q[u])return I(p[u],q[u]);return u===n?I(g,q[u],-1):I(p[u],i,1)};I=function(g,i,n){if(g===i)return n;for(g=g.nextSibling;g;){if(g===i)return-1;g=g.nextSibling}return 1}}k.getText=function(g){for(var i="",n,m=0;g[m];m++){n=g[m];if(n.nodeType===3||n.nodeType===4)i+=n.nodeValue;else if(n.nodeType!==8)i+=k.getText(n.childNodes)}return i};(function(){var g=t.createElement("div"),
i="script"+(new Date).getTime(),n=t.documentElement;g.innerHTML="<a name='"+i+"'/>";n.insertBefore(g,n.firstChild);if(t.getElementById(i)){o.find.ID=function(m,p,q){if(typeof p.getElementById!=="undefined"&&!q)return(p=p.getElementById(m[1]))?p.id===m[1]||typeof p.getAttributeNode!=="undefined"&&p.getAttributeNode("id").nodeValue===m[1]?[p]:B:[]};o.filter.ID=function(m,p){var q=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&q&&q.nodeValue===p}}n.removeChild(g);
n=g=null})();(function(){var g=t.createElement("div");g.appendChild(t.createComment(""));if(g.getElementsByTagName("*").length>0)o.find.TAG=function(i,n){var m=n.getElementsByTagName(i[1]);if(i[1]==="*"){for(var p=[],q=0;m[q];q++)m[q].nodeType===1&&p.push(m[q]);m=p}return m};g.innerHTML="<a href='#'></a>";if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")o.attrHandle.href=function(i){return i.getAttribute("href",2)};g=null})();t.querySelectorAll&&
function(){var g=k,i=t.createElement("div");i.innerHTML="<p class='TEST'></p>";if(!(i.querySelectorAll&&i.querySelectorAll(".TEST").length===0)){k=function(m,p,q,u){p=p||t;m=m.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!u&&!k.isXML(p))if(p.nodeType===9)try{return C(p.querySelectorAll(m),q)}catch(y){}else if(p.nodeType===1&&p.nodeName.toLowerCase()!=="object"){var F=p.getAttribute("id"),M=F||"__sizzle__";F||p.setAttribute("id",M);try{return C(p.querySelectorAll("#"+M+" "+m),q)}catch(N){}finally{F||
p.removeAttribute("id")}}return g(m,p,q,u)};for(var n in g)k[n]=g[n];i=null}}();(function(){var g=t.documentElement,i=g.matchesSelector||g.mozMatchesSelector||g.webkitMatchesSelector||g.msMatchesSelector,n=false;try{i.call(t.documentElement,"[test!='']:sizzle")}catch(m){n=true}if(i)k.matchesSelector=function(p,q){q=q.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!k.isXML(p))try{if(n||!o.match.PSEUDO.test(q)&&!/!=/.test(q))return i.call(p,q)}catch(u){}return k(q,null,null,[p]).length>0}})();(function(){var g=
t.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){o.order.splice(1,0,"CLASS");o.find.CLASS=function(i,n,m){if(typeof n.getElementsByClassName!=="undefined"&&!m)return n.getElementsByClassName(i[1])};g=null}}})();k.contains=t.documentElement.contains?function(g,i){return g!==i&&(g.contains?g.contains(i):true)}:t.documentElement.compareDocumentPosition?
function(g,i){return!!(g.compareDocumentPosition(i)&16)}:function(){return false};k.isXML=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false};var L=function(g,i){for(var n,m=[],p="",q=i.nodeType?[i]:i;n=o.match.PSEUDO.exec(g);){p+=n[0];g=g.replace(o.match.PSEUDO,"")}g=o.relative[g]?g+"*":g;n=0;for(var u=q.length;n<u;n++)k(g,q[n],m);return k.filter(p,m)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=k.getText;c.isXMLDoc=k.isXML;
c.contains=k.contains})();var Za=/Until$/,$a=/^(?:parents|prevUntil|prevAll)/,ab=/,/,Na=/^.[^:#\[\.,]*$/,bb=Array.prototype.slice,cb=c.expr.match.POS;c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,e=0,f=this.length;e<f;e++){d=b.length;c.find(a,this[e],b);if(e>0)for(var h=d;h<b.length;h++)for(var l=0;l<d;l++)if(b[l]===b[h]){b.splice(h--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,e=b.length;d<e;d++)if(c.contains(this,b[d]))return true})},
not:function(a){return this.pushStack(ma(this,a,false),"not",a)},filter:function(a){return this.pushStack(ma(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){var d=[],e,f,h=this[0];if(c.isArray(a)){var l,k={},o=1;if(h&&a.length){e=0;for(f=a.length;e<f;e++){l=a[e];k[l]||(k[l]=c.expr.match.POS.test(l)?c(l,b||this.context):l)}for(;h&&h.ownerDocument&&h!==b;){for(l in k){e=k[l];if(e.jquery?e.index(h)>-1:c(h).is(e))d.push({selector:l,elem:h,level:o})}h=
h.parentNode;o++}}return d}l=cb.test(a)?c(a,b||this.context):null;e=0;for(f=this.length;e<f;e++)for(h=this[e];h;)if(l?l.index(h)>-1:c.find.matchesSelector(h,a)){d.push(h);break}else{h=h.parentNode;if(!h||!h.ownerDocument||h===b)break}d=d.length>1?c.unique(d):d;return this.pushStack(d,"closest",a)},index:function(a){if(!a||typeof a==="string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var d=typeof a==="string"?c(a,b||this.context):
c.makeArray(a),e=c.merge(this.get(),d);return this.pushStack(!d[0]||!d[0].parentNode||d[0].parentNode.nodeType===11||!e[0]||!e[0].parentNode||e[0].parentNode.nodeType===11?e:c.unique(e))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,
2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,
b){c.fn[a]=function(d,e){var f=c.map(this,b,d);Za.test(a)||(e=d);if(e&&typeof e==="string")f=c.filter(e,f);f=this.length>1?c.unique(f):f;if((this.length>1||ab.test(e))&&$a.test(a))f=f.reverse();return this.pushStack(f,a,bb.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return b.length===1?c.find.matchesSelector(b[0],a)?[b[0]]:[]:c.find.matches(a,b)},dir:function(a,b,d){var e=[];for(a=a[b];a&&a.nodeType!==9&&(d===B||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&
e.push(a);a=a[b]}return e},nth:function(a,b,d){b=b||1;for(var e=0;a;a=a[d])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var za=/ jQuery\d+="(?:\d+|null)"/g,$=/^\s+/,Aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Ba=/<([\w:]+)/,db=/<tbody/i,eb=/<|&#?\w+;/,Ca=/<(?:script|object|embed|option|style)/i,Da=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/\=([^="'>\s]+\/)>/g,P={option:[1,
"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};P.optgroup=P.option;P.tbody=P.tfoot=P.colgroup=P.caption=P.thead;P.th=P.td;if(!c.support.htmlSerialize)P._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==B)return this.empty().append((this[0]&&this[0].ownerDocument||t).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,e;(e=this[d])!=null;d++)if(!a||c.filter(a,[e]).length){if(!b&&e.nodeType===1){c.cleanData(e.getElementsByTagName("*"));c.cleanData([e])}e.parentNode&&e.parentNode.removeChild(e)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,e=this.ownerDocument;if(!d){d=e.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(za,"").replace(fb,'="$1">').replace($,"")],e)[0]}else return this.cloneNode(true)});if(a===true){na(this,b);na(this.find("*"),b.find("*"))}return b},html:function(a){if(a===B)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(za,""):null;
else if(typeof a==="string"&&!Ca.test(a)&&(c.support.leadingWhitespace||!$.test(a))&&!P[(Ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Aa,"<$1></$2>");try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(e){this.empty().append(a)}}else c.isFunction(a)?this.each(function(f){var h=c(this);h.html(a.call(this,f,h.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=
c(this),e=d.html();d.replaceWith(a.call(this,b,e))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){var e,f,h,l=a[0],k=[];if(!c.support.checkClone&&arguments.length===3&&typeof l==="string"&&Da.test(l))return this.each(function(){c(this).domManip(a,
b,d,true)});if(c.isFunction(l))return this.each(function(x){var r=c(this);a[0]=l.call(this,x,b?r.html():B);r.domManip(a,b,d)});if(this[0]){e=l&&l.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:c.buildFragment(a,this,k);h=e.fragment;if(f=h.childNodes.length===1?h=h.firstChild:h.firstChild){b=b&&c.nodeName(f,"tr");f=0;for(var o=this.length;f<o;f++)d.call(b?c.nodeName(this[f],"table")?this[f].getElementsByTagName("tbody")[0]||this[f].appendChild(this[f].ownerDocument.createElement("tbody")):
this[f]:this[f],f>0||e.cacheable||this.length>1?h.cloneNode(true):h)}k.length&&c.each(k,Oa)}return this}});c.buildFragment=function(a,b,d){var e,f,h;b=b&&b[0]?b[0].ownerDocument||b[0]:t;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===t&&!Ca.test(a[0])&&(c.support.checkClone||!Da.test(a[0]))){f=true;if(h=c.fragments[a[0]])if(h!==1)e=h}if(!e){e=b.createDocumentFragment();c.clean(a,b,e,d)}if(f)c.fragments[a[0]]=h?e:1;return{fragment:e,cacheable:f}};c.fragments={};c.each({appendTo:"append",
prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var e=[];d=c(d);var f=this.length===1&&this[0].parentNode;if(f&&f.nodeType===11&&f.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{f=0;for(var h=d.length;f<h;f++){var l=(f>0?this.clone(true):this).get();c(d[f])[b](l);e=e.concat(l)}return this.pushStack(e,a,d.selector)}}});c.extend({clean:function(a,b,d,e){b=b||t;if(typeof b.createElement==="undefined")b=b.ownerDocument||
b[0]&&b[0].ownerDocument||t;for(var f=[],h=0,l;(l=a[h])!=null;h++){if(typeof l==="number")l+="";if(l){if(typeof l==="string"&&!eb.test(l))l=b.createTextNode(l);else if(typeof l==="string"){l=l.replace(Aa,"<$1></$2>");var k=(Ba.exec(l)||["",""])[1].toLowerCase(),o=P[k]||P._default,x=o[0],r=b.createElement("div");for(r.innerHTML=o[1]+l+o[2];x--;)r=r.lastChild;if(!c.support.tbody){x=db.test(l);k=k==="table"&&!x?r.firstChild&&r.firstChild.childNodes:o[1]==="<table>"&&!x?r.childNodes:[];for(o=k.length-
1;o>=0;--o)c.nodeName(k[o],"tbody")&&!k[o].childNodes.length&&k[o].parentNode.removeChild(k[o])}!c.support.leadingWhitespace&&$.test(l)&&r.insertBefore(b.createTextNode($.exec(l)[0]),r.firstChild);l=r.childNodes}if(l.nodeType)f.push(l);else f=c.merge(f,l)}}if(d)for(h=0;f[h];h++)if(e&&c.nodeName(f[h],"script")&&(!f[h].type||f[h].type.toLowerCase()==="text/javascript"))e.push(f[h].parentNode?f[h].parentNode.removeChild(f[h]):f[h]);else{f[h].nodeType===1&&f.splice.apply(f,[h+1,0].concat(c.makeArray(f[h].getElementsByTagName("script"))));
d.appendChild(f[h])}return f},cleanData:function(a){for(var b,d,e=c.cache,f=c.event.special,h=c.support.deleteExpando,l=0,k;(k=a[l])!=null;l++)if(!(k.nodeName&&c.noData[k.nodeName.toLowerCase()]))if(d=k[c.expando]){if((b=e[d])&&b.events)for(var o in b.events)f[o]?c.event.remove(k,o):c.removeEvent(k,o,b.handle);if(h)delete k[c.expando];else k.removeAttribute&&k.removeAttribute(c.expando);delete e[d]}}});var Ea=/alpha\([^)]*\)/i,gb=/opacity=([^)]*)/,hb=/-([a-z])/ig,ib=/([A-Z])/g,Fa=/^-?\d+(?:px)?$/i,
jb=/^-?\d/,kb={position:"absolute",visibility:"hidden",display:"block"},Pa=["Left","Right"],Qa=["Top","Bottom"],W,Ga,aa,lb=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){if(arguments.length===2&&b===B)return this;return c.access(this,a,b,true,function(d,e,f){return f!==B?c.style(d,e,f):c.css(d,e)})};c.extend({cssHooks:{opacity:{get:function(a,b){if(b){var d=W(a,"opacity","opacity");return d===""?"1":d}else return a.style.opacity}}},cssNumber:{zIndex:true,fontWeight:true,opacity:true,
zoom:true,lineHeight:true},cssProps:{"float":c.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,d,e){if(!(!a||a.nodeType===3||a.nodeType===8||!a.style)){var f,h=c.camelCase(b),l=a.style,k=c.cssHooks[h];b=c.cssProps[h]||h;if(d!==B){if(!(typeof d==="number"&&isNaN(d)||d==null)){if(typeof d==="number"&&!c.cssNumber[h])d+="px";if(!k||!("set"in k)||(d=k.set(a,d))!==B)try{l[b]=d}catch(o){}}}else{if(k&&"get"in k&&(f=k.get(a,false,e))!==B)return f;return l[b]}}},css:function(a,b,d){var e,f=c.camelCase(b),
h=c.cssHooks[f];b=c.cssProps[f]||f;if(h&&"get"in h&&(e=h.get(a,true,d))!==B)return e;else if(W)return W(a,b,f)},swap:function(a,b,d){var e={},f;for(f in b){e[f]=a.style[f];a.style[f]=b[f]}d.call(a);for(f in b)a.style[f]=e[f]},camelCase:function(a){return a.replace(hb,lb)}});c.curCSS=c.css;c.each(["height","width"],function(a,b){c.cssHooks[b]={get:function(d,e,f){var h;if(e){if(d.offsetWidth!==0)h=oa(d,b,f);else c.swap(d,kb,function(){h=oa(d,b,f)});if(h<=0){h=W(d,b,b);if(h==="0px"&&aa)h=aa(d,b,b);
if(h!=null)return h===""||h==="auto"?"0px":h}if(h<0||h==null){h=d.style[b];return h===""||h==="auto"?"0px":h}return typeof h==="string"?h:h+"px"}},set:function(d,e){if(Fa.test(e)){e=parseFloat(e);if(e>=0)return e+"px"}else return e}}});if(!c.support.opacity)c.cssHooks.opacity={get:function(a,b){return gb.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var d=a.style;d.zoom=1;var e=c.isNaN(b)?"":"alpha(opacity="+b*100+")",f=
d.filter||"";d.filter=Ea.test(f)?f.replace(Ea,e):d.filter+" "+e}};if(t.defaultView&&t.defaultView.getComputedStyle)Ga=function(a,b,d){var e;d=d.replace(ib,"-$1").toLowerCase();if(!(b=a.ownerDocument.defaultView))return B;if(b=b.getComputedStyle(a,null)){e=b.getPropertyValue(d);if(e===""&&!c.contains(a.ownerDocument.documentElement,a))e=c.style(a,d)}return e};if(t.documentElement.currentStyle)aa=function(a,b){var d,e,f=a.currentStyle&&a.currentStyle[b],h=a.style;if(!Fa.test(f)&&jb.test(f)){d=h.left;
e=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;h.left=b==="fontSize"?"1em":f||0;f=h.pixelLeft+"px";h.left=d;a.runtimeStyle.left=e}return f===""?"auto":f};W=Ga||aa;if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetHeight;return a.offsetWidth===0&&b===0||!c.support.reliableHiddenOffsets&&(a.style.display||c.css(a,"display"))==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var mb=c.now(),nb=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
ob=/^(?:select|textarea)/i,pb=/^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,qb=/^(?:GET|HEAD)$/,Ra=/\[\]$/,T=/\=\?(&|$)/,ja=/\?/,rb=/([?&])_=[^&]*/,sb=/^(\w+:)?\/\/([^\/?#]+)/,tb=/%20/g,ub=/#.*$/,Ha=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!=="string"&&Ha)return Ha.apply(this,arguments);else if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var f=a.slice(e,a.length);a=a.slice(0,e)}e="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===
"object"){b=c.param(b,c.ajaxSettings.traditional);e="POST"}var h=this;c.ajax({url:a,type:e,dataType:"html",data:b,complete:function(l,k){if(k==="success"||k==="notmodified")h.html(f?c("<div>").append(l.responseText.replace(nb,"")).find(f):l.responseText);d&&h.each(d,[l.responseText,k,l])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&
!this.disabled&&(this.checked||ob.test(this.nodeName)||pb.test(this.type))}).map(function(a,b){var d=c(this).val();return d==null?null:c.isArray(d)?c.map(d,function(e){return{name:b.name,value:e}}):{name:b.name,value:d}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:e})},
getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:e})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:function(){return new E.XMLHttpRequest},accepts:{xml:"application/xml, text/xml",html:"text/html",
script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},ajax:function(a){var b=c.extend(true,{},c.ajaxSettings,a),d,e,f,h=b.type.toUpperCase(),l=qb.test(h);b.url=b.url.replace(ub,"");b.context=a&&a.context!=null?a.context:b;if(b.data&&b.processData&&typeof b.data!=="string")b.data=c.param(b.data,b.traditional);if(b.dataType==="jsonp"){if(h==="GET")T.test(b.url)||(b.url+=(ja.test(b.url)?"&":"?")+(b.jsonp||"callback")+"=?");else if(!b.data||
!T.test(b.data))b.data=(b.data?b.data+"&":"")+(b.jsonp||"callback")+"=?";b.dataType="json"}if(b.dataType==="json"&&(b.data&&T.test(b.data)||T.test(b.url))){d=b.jsonpCallback||"jsonp"+mb++;if(b.data)b.data=(b.data+"").replace(T,"="+d+"$1");b.url=b.url.replace(T,"="+d+"$1");b.dataType="script";var k=E[d];E[d]=function(m){if(c.isFunction(k))k(m);else{E[d]=B;try{delete E[d]}catch(p){}}f=m;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);r&&r.removeChild(A)}}if(b.dataType==="script"&&b.cache===null)b.cache=
false;if(b.cache===false&&l){var o=c.now(),x=b.url.replace(rb,"$1_="+o);b.url=x+(x===b.url?(ja.test(b.url)?"&":"?")+"_="+o:"")}if(b.data&&l)b.url+=(ja.test(b.url)?"&":"?")+b.data;b.global&&c.active++===0&&c.event.trigger("ajaxStart");o=(o=sb.exec(b.url))&&(o[1]&&o[1].toLowerCase()!==location.protocol||o[2].toLowerCase()!==location.host);if(b.dataType==="script"&&h==="GET"&&o){var r=t.getElementsByTagName("head")[0]||t.documentElement,A=t.createElement("script");if(b.scriptCharset)A.charset=b.scriptCharset;
A.src=b.url;if(!d){var C=false;A.onload=A.onreadystatechange=function(){if(!C&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){C=true;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);A.onload=A.onreadystatechange=null;r&&A.parentNode&&r.removeChild(A)}}}r.insertBefore(A,r.firstChild);return B}var J=false,w=b.xhr();if(w){b.username?w.open(h,b.url,b.async,b.username,b.password):w.open(h,b.url,b.async);try{if(b.data!=null&&!l||a&&a.contentType)w.setRequestHeader("Content-Type",
b.contentType);if(b.ifModified){c.lastModified[b.url]&&w.setRequestHeader("If-Modified-Since",c.lastModified[b.url]);c.etag[b.url]&&w.setRequestHeader("If-None-Match",c.etag[b.url])}o||w.setRequestHeader("X-Requested-With","XMLHttpRequest");w.setRequestHeader("Accept",b.dataType&&b.accepts[b.dataType]?b.accepts[b.dataType]+", */*; q=0.01":b.accepts._default)}catch(I){}if(b.beforeSend&&b.beforeSend.call(b.context,w,b)===false){b.global&&c.active--===1&&c.event.trigger("ajaxStop");w.abort();return false}b.global&&
c.triggerGlobal(b,"ajaxSend",[w,b]);var L=w.onreadystatechange=function(m){if(!w||w.readyState===0||m==="abort"){J||c.handleComplete(b,w,e,f);J=true;if(w)w.onreadystatechange=c.noop}else if(!J&&w&&(w.readyState===4||m==="timeout")){J=true;w.onreadystatechange=c.noop;e=m==="timeout"?"timeout":!c.httpSuccess(w)?"error":b.ifModified&&c.httpNotModified(w,b.url)?"notmodified":"success";var p;if(e==="success")try{f=c.httpData(w,b.dataType,b)}catch(q){e="parsererror";p=q}if(e==="success"||e==="notmodified")d||
c.handleSuccess(b,w,e,f);else c.handleError(b,w,e,p);d||c.handleComplete(b,w,e,f);m==="timeout"&&w.abort();if(b.async)w=null}};try{var g=w.abort;w.abort=function(){w&&Function.prototype.call.call(g,w);L("abort")}}catch(i){}b.async&&b.timeout>0&&setTimeout(function(){w&&!J&&L("timeout")},b.timeout);try{w.send(l||b.data==null?null:b.data)}catch(n){c.handleError(b,w,null,n);c.handleComplete(b,w,e,f)}b.async||L();return w}},param:function(a,b){var d=[],e=function(h,l){l=c.isFunction(l)?l():l;d[d.length]=
encodeURIComponent(h)+"="+encodeURIComponent(l)};if(b===B)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){e(this.name,this.value)});else for(var f in a)da(f,a[f],b,e);return d.join("&").replace(tb,"+")}});c.extend({active:0,lastModified:{},etag:{},handleError:function(a,b,d,e){a.error&&a.error.call(a.context,b,d,e);a.global&&c.triggerGlobal(a,"ajaxError",[b,a,e])},handleSuccess:function(a,b,d,e){a.success&&a.success.call(a.context,e,d,b);a.global&&c.triggerGlobal(a,"ajaxSuccess",
[b,a])},handleComplete:function(a,b,d){a.complete&&a.complete.call(a.context,b,d);a.global&&c.triggerGlobal(a,"ajaxComplete",[b,a]);a.global&&c.active--===1&&c.event.trigger("ajaxStop")},triggerGlobal:function(a,b,d){(a.context&&a.context.url==null?c(a.context):c.event).trigger(b,d)},httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===1223}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),
e=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(e)c.etag[b]=e;return a.status===304},httpData:function(a,b,d){var e=a.getResponseHeader("content-type")||"",f=b==="xml"||!b&&e.indexOf("xml")>=0;a=f?a.responseXML:a.responseText;f&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b==="json"||!b&&e.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&e.indexOf("javascript")>=0)c.globalEval(a);return a}});
if(E.ActiveXObject)c.ajaxSettings.xhr=function(){if(E.location.protocol!=="file:")try{return new E.XMLHttpRequest}catch(a){}try{return new E.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}};c.support.ajax=!!c.ajaxSettings.xhr();var ea={},vb=/^(?:toggle|show|hide)$/,wb=/^([+\-]=)?([\d+.\-]+)(.*)$/,ba,pa=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b,d){if(a||a===0)return this.animate(S("show",
3),a,b,d);else{d=0;for(var e=this.length;d<e;d++){a=this[d];b=a.style.display;if(!c.data(a,"olddisplay")&&b==="none")b=a.style.display="";b===""&&c.css(a,"display")==="none"&&c.data(a,"olddisplay",qa(a.nodeName))}for(d=0;d<e;d++){a=this[d];b=a.style.display;if(b===""||b==="none")a.style.display=c.data(a,"olddisplay")||""}return this}},hide:function(a,b,d){if(a||a===0)return this.animate(S("hide",3),a,b,d);else{a=0;for(b=this.length;a<b;a++){d=c.css(this[a],"display");d!=="none"&&c.data(this[a],"olddisplay",
d)}for(a=0;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b,d){var e=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||e?this.each(function(){var f=e?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(S("toggle",3),a,b,d);return this},fadeTo:function(a,b,d,e){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d,e)},animate:function(a,b,d,e){var f=c.speed(b,
d,e);if(c.isEmptyObject(a))return this.each(f.complete);return this[f.queue===false?"each":"queue"](function(){var h=c.extend({},f),l,k=this.nodeType===1,o=k&&c(this).is(":hidden"),x=this;for(l in a){var r=c.camelCase(l);if(l!==r){a[r]=a[l];delete a[l];l=r}if(a[l]==="hide"&&o||a[l]==="show"&&!o)return h.complete.call(this);if(k&&(l==="height"||l==="width")){h.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY];if(c.css(this,"display")==="inline"&&c.css(this,"float")==="none")if(c.support.inlineBlockNeedsLayout)if(qa(this.nodeName)===
"inline")this.style.display="inline-block";else{this.style.display="inline";this.style.zoom=1}else this.style.display="inline-block"}if(c.isArray(a[l])){(h.specialEasing=h.specialEasing||{})[l]=a[l][1];a[l]=a[l][0]}}if(h.overflow!=null)this.style.overflow="hidden";h.curAnim=c.extend({},a);c.each(a,function(A,C){var J=new c.fx(x,h,A);if(vb.test(C))J[C==="toggle"?o?"show":"hide":C](a);else{var w=wb.exec(C),I=J.cur()||0;if(w){var L=parseFloat(w[2]),g=w[3]||"px";if(g!=="px"){c.style(x,A,(L||1)+g);I=(L||
1)/J.cur()*I;c.style(x,A,I+g)}if(w[1])L=(w[1]==="-="?-1:1)*L+I;J.custom(I,L,g)}else J.custom(I,C,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var e=d.length-1;e>=0;e--)if(d[e].elem===this){b&&d[e](true);d.splice(e,1)}});b||this.dequeue();return this}});c.each({slideDown:S("show",1),slideUp:S("hide",1),slideToggle:S("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){c.fn[a]=function(d,e,f){return this.animate(b,
d,e,f)}});c.extend({speed:function(a,b,d){var e=a&&typeof a==="object"?c.extend({},a):{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};e.duration=c.fx.off?0:typeof e.duration==="number"?e.duration:e.duration in c.fx.speeds?c.fx.speeds[e.duration]:c.fx.speeds._default;e.old=e.complete;e.complete=function(){e.queue!==false&&c(this).dequeue();c.isFunction(e.old)&&e.old.call(this)};return e},easing:{linear:function(a,b,d,e){return d+e*a},swing:function(a,b,d,e){return(-Math.cos(a*
Math.PI)/2+0.5)*e+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a=parseFloat(c.css(this.elem,this.prop));return a&&a>-1E4?a:0},custom:function(a,b,d){function e(l){return f.step(l)}
var f=this,h=c.fx;this.startTime=c.now();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;this.pos=this.state=0;e.elem=this.elem;if(e()&&c.timers.push(e)&&!ba)ba=setInterval(h.tick,h.interval)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;
this.custom(this.cur(),0)},step:function(a){var b=c.now(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var e in this.options.curAnim)if(this.options.curAnim[e]!==true)d=false;if(d){if(this.options.overflow!=null&&!c.support.shrinkWrapBlocks){var f=this.elem,h=this.options;c.each(["","X","Y"],function(k,o){f.style["overflow"+o]=h.overflow[k]})}this.options.hide&&c(this.elem).hide();if(this.options.hide||
this.options.show)for(var l in this.options.curAnim)c.style(this.elem,l,this.options.orig[l]);this.options.complete.call(this.elem)}return false}else{a=b-this.startTime;this.state=a/this.options.duration;b=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||b](this.state,a,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=
c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},interval:13,stop:function(){clearInterval(ba);ba=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===
b.elem}).length};var xb=/^t(?:able|d|h)$/i,Ia=/^(?:body|html)$/i;c.fn.offset="getBoundingClientRect"in t.documentElement?function(a){var b=this[0],d;if(a)return this.each(function(l){c.offset.setOffset(this,a,l)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);try{d=b.getBoundingClientRect()}catch(e){}var f=b.ownerDocument,h=f.documentElement;if(!d||!c.contains(h,b))return d||{top:0,left:0};b=f.body;f=fa(f);return{top:d.top+(f.pageYOffset||c.support.boxModel&&
h.scrollTop||b.scrollTop)-(h.clientTop||b.clientTop||0),left:d.left+(f.pageXOffset||c.support.boxModel&&h.scrollLeft||b.scrollLeft)-(h.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(x){c.offset.setOffset(this,a,x)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d,e=b.offsetParent,f=b.ownerDocument,h=f.documentElement,l=f.body;d=(f=f.defaultView)?f.getComputedStyle(b,null):b.currentStyle;
for(var k=b.offsetTop,o=b.offsetLeft;(b=b.parentNode)&&b!==l&&b!==h;){if(c.offset.supportsFixedPosition&&d.position==="fixed")break;d=f?f.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;o-=b.scrollLeft;if(b===e){k+=b.offsetTop;o+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&xb.test(b.nodeName))){k+=parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}e=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"){k+=
parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}d=d}if(d.position==="relative"||d.position==="static"){k+=l.offsetTop;o+=l.offsetLeft}if(c.offset.supportsFixedPosition&&d.position==="fixed"){k+=Math.max(h.scrollTop,l.scrollTop);o+=Math.max(h.scrollLeft,l.scrollLeft)}return{top:k,left:o}};c.offset={initialize:function(){var a=t.body,b=t.createElement("div"),d,e,f,h=parseFloat(c.css(a,"marginTop"))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",
height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";a.insertBefore(b,a.firstChild);d=b.firstChild;e=d.firstChild;f=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=e.offsetTop!==5;this.doesAddBorderForTableAndCells=
f.offsetTop===5;e.style.position="fixed";e.style.top="20px";this.supportsFixedPosition=e.offsetTop===20||e.offsetTop===15;e.style.position=e.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=e.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==h;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.css(a,
"marginTop"))||0;d+=parseFloat(c.css(a,"marginLeft"))||0}return{top:b,left:d}},setOffset:function(a,b,d){var e=c.css(a,"position");if(e==="static")a.style.position="relative";var f=c(a),h=f.offset(),l=c.css(a,"top"),k=c.css(a,"left"),o=e==="absolute"&&c.inArray("auto",[l,k])>-1;e={};var x={};if(o)x=f.position();l=o?x.top:parseInt(l,10)||0;k=o?x.left:parseInt(k,10)||0;if(c.isFunction(b))b=b.call(a,d,h);if(b.top!=null)e.top=b.top-h.top+l;if(b.left!=null)e.left=b.left-h.left+k;"using"in b?b.using.call(a,
e):f.css(e)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),e=Ia.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.css(a,"marginTop"))||0;d.left-=parseFloat(c.css(a,"marginLeft"))||0;e.top+=parseFloat(c.css(b[0],"borderTopWidth"))||0;e.left+=parseFloat(c.css(b[0],"borderLeftWidth"))||0;return{top:d.top-e.top,left:d.left-e.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||t.body;a&&!Ia.test(a.nodeName)&&
c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(e){var f=this[0],h;if(!f)return null;if(e!==B)return this.each(function(){if(h=fa(this))h.scrollTo(!a?e:c(h).scrollLeft(),a?e:c(h).scrollTop());else this[d]=e});else return(h=fa(f))?"pageXOffset"in h?h[a?"pageYOffset":"pageXOffset"]:c.support.boxModel&&h.document.documentElement[d]||h.document.body[d]:f[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();
c.fn["inner"+b]=function(){return this[0]?parseFloat(c.css(this[0],d,"padding")):null};c.fn["outer"+b]=function(e){return this[0]?parseFloat(c.css(this[0],d,e?"margin":"border")):null};c.fn[d]=function(e){var f=this[0];if(!f)return e==null?null:this;if(c.isFunction(e))return this.each(function(l){var k=c(this);k[d](e.call(this,l,k[d]()))});if(c.isWindow(f))return f.document.compatMode==="CSS1Compat"&&f.document.documentElement["client"+b]||f.document.body["client"+b];else if(f.nodeType===9)return Math.max(f.documentElement["client"+
b],f.body["scroll"+b],f.documentElement["scroll"+b],f.body["offset"+b],f.documentElement["offset"+b]);else if(e===B){f=c.css(f,d);var h=parseFloat(f);return c.isNaN(h)?f:h}else return this.css(d,typeof e==="string"?e:e+"px")}})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>fnx -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name">fnx</h1><h2 class="project-version">1.0.0-SNAPSHOT</h2><br /><p>Expose your Clojure functions on the web easily</p>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.3.0</td></tr><tr><td class="dep-name">ring</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0-RC1</td></tr><tr><td class="dep-name">compojure</td><td class="dotted"><hr /></td><td class="dep-version">0.6.4</td></tr><tr><td class="dep-name">enlive</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0</td></tr><tr><td class="dep-name">org.mozilla/rhino</td><td class="dotted"><hr /></td><td class="dep-version">1.7R3</td></tr><tr><td class="dep-name">com.google.javascript/closure-compiler</td><td class="dotted"><hr /></td><td class="dep-version">r1592</td></tr><tr><td class="dep-name">org.clojure/google-closure-library</td><td class="dotted"><hr /></td><td class="dep-version">0.0-790</td></tr><tr><td class="dep-name">midje</td><td class="dotted"><hr /></td><td class="dep-version">1.3.1</td></tr></table></div><div class="dependencies"><h3>dev dependencies</h3><table><tr><td class="dep-name">jline</td><td class="dotted"><hr /></td><td class="dep-version">0.9.94</td></tr><tr><td class="dep-name">marginalia</td><td class="dotted"><hr /></td><td class="dep-version">0.7.0</td></tr><tr><td class="dep-name">lein-marginalia</td><td class="dotted"><hr /></td><td class="dep-version">0.7.0</td></tr><tr><td class="dep-name">com.intelie/lazytest</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0-SNAPSHOT</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#fnx.meta.example">fnx.meta.example</a></li><li><a href="#fnx.meta.example2">fnx.meta.example2</a></li><li><a href="#fnx.meta.expose">fnx.meta.expose</a></li><li><a href="#one.sample.api">one.sample.api</a></li><li><a href="#one.sample.config">one.sample.config</a></li><li><a href="#one.sample.dev-server">one.sample.dev-server</a></li><li><a href="#one.sample.prod-server">one.sample.prod-server</a></li><li><a href="#one.sample.repl">one.sample.repl</a></li><li><a href="#script.build">script.build</a></li><li><a href="#script.serve">script.serve</a></li><li><a href="#one.sample.snippets">one.sample.snippets</a></li><li><a href="#leiningen.bootstrap">leiningen.bootstrap</a></li><li><a href="#leiningen.git-deps">leiningen.git-deps</a></li><li><a href="#one.config">one.config</a></li><li><a href="#one.host-page">one.host-page</a></li><li><a href="#one.reload">one.reload</a></li><li><a href="#one.templates">one.templates</a></li><li><a href="#one.test">one.test</a></li><li><a href="#one.tools">one.tools</a></li><li><a href="#script.docs">script.docs</a></li><li><a href="#one.sample.animation">one.sample.animation</a></li><li><a href="#one.sample.controller">one.sample.controller</a></li><li><a href="#one.sample.core">one.sample.core</a></li><li><a href="#one.sample.history">one.sample.history</a></li><li><a href="#one.sample.logging">one.sample.logging</a></li><li><a href="#one.sample.model">one.sample.model</a></li><li><a href="#one.sample.view">one.sample.view</a></li><li><a href="#one.sample.view-helper">one.sample.view-helper</a></li><li><a href="#one.browser.animation">one.browser.animation</a></li><li><a href="#one.browser.history">one.browser.history</a></li><li><a href="#one.browser.remote">one.browser.remote</a></li><li><a href="#one.color">one.color</a></li><li><a href="#one.core">one.core</a></li><li><a href="#one.dispatch">one.dispatch</a></li><li><a href="#one.logging">one.logging</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#fnx.meta.example" name="fnx.meta.example"><h1 class="project-name">fnx.meta.example</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Example of namespace that exposes functions..</p>

<p>This file contains some dummy functions and vars <strong>just to test</strong> the
functionnalities of <code>fnx.meta.expose</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(ns fnx.meta.example)</pre></td></tr><tr><td class="docs"><p>A public fn with zero arg, should be listed</p>
</td><td class="codes"><pre class="brush: clojure">(defn hello-noir 
  [] (str &quot;Hello world from a function exposed!&quot;))</pre></td></tr><tr><td class="docs"><p>A public fn with one arg, should be listed</p>
</td><td class="codes"><pre class="brush: clojure">(defn one-arg-fn 
  [x] (str &quot;arg=&quot; x))</pre></td></tr><tr><td class="docs"><p>A public fn with two args, should be listed</p>
</td><td class="codes"><pre class="brush: clojure">(defn two-arg-fn 
  [x y] (str &quot;args=&quot; x &quot;,&quot; y))</pre></td></tr><tr><td class="docs"><p>A private fn that shouldn't be listed</p>
</td><td class="codes"><pre class="brush: clojure">(defn- hello-private 
  [] (str &quot;Hello noir, today we are &quot; (java.util.Date.)))</pre></td></tr><tr><td class="docs"><p>A public var that shouldn't be listed</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  a-public-var-that-shouldnt-be-list 0)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#fnx.meta.example2" name="fnx.meta.example2"><h1 class="project-name">fnx.meta.example2</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Another Example of namespace that exposes functions..</p>

<p>This other file contains some other dummy functions
and vars <strong>just to test</strong> the functionnalities of <code>fnx.meta.expose</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(ns fnx.meta.example2)</pre></td></tr><tr><td class="docs"><p>A public fn with zero arg, should be listed</p>
</td><td class="codes"><pre class="brush: clojure">(defn hello 
  [] (str &quot;Hello world from a function exposed!&quot;))</pre></td></tr><tr><td class="docs"><p>A public fn with one arg, should be listed</p>
</td><td class="codes"><pre class="brush: clojure">(defn three-arg-fn 
  [x y z] (str &quot;arg=&quot; x y z))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#fnx.meta.expose" name="fnx.meta.expose"><h1 class="project-name">fnx.meta.expose</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Expose the public functions of a namespace</p>

<p>This is usefull to display the functions, ask the user for the
input parameters, and then execute them, presenting the result to
the user.
Intended to expose the functions in a Browser, but it could be
anything else: command line, rich client, ...</p>
</td><td class="codes"><pre class="brush: clojure">(ns fnx.meta.expose
  (:use [clojure.string :only [split join escape]]
        [midje.sweet]))</pre></td></tr><tr><td class="docs"><p>Given a ns symbol, returns all the public fns of this ns.</p>

<ul>
<li>First we load the ns with <code>require</code></li>
<li>Then we get the public functions (read from bottom to top):</li>
<li>We want only functions, not the other vars: We can spot them because they have an <code>:arglists</code> in their meta.</li>
<li>Get the public vars with <code>ns-publics</code></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn- ns-public-fn
  [ns] (do (require ns)
           (filter #(:arglists (meta %))
                   (vals (ns-publics (find-ns ns))))))</pre></td></tr><tr><td class="docs"><p>Transform a function name without the #' in front of its name.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- fun-str 
  [s]
  (join &quot;&quot; (drop 2 s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;fun-str&quot;
  (fun-str &quot;#'test&quot;) =&gt; &quot;test&quot;)</pre></td></tr><tr><td class="docs"><p>Wrapper around 'resolve' to deal with string representing #'namespace/function</p>
</td><td class="codes"><pre class="brush: clojure">(defn- resolve-str 
  [s]
  (resolve (symbol s)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;resolve-str&quot;
  (resolve-str &quot;fnx.meta.expose/resolve-str&quot;) =&gt; #'fnx.meta.expose/resolve-str)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(unfinished )</pre></td></tr><tr><td class="docs"><p>Given a map of parameters and a list of ordered parameters, return the valued parameters from the map in order.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- parameters 
  [arglists args]
  (let [arities (group-by count arglists)
        n (count (vals args))
        arity (first (arities n))]
    (map args arity)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;parameters&quot;
  (parameters [['a] ['a 'b] ['a 'b 'c]]
              {'c :30 'b :20 'a :10}) =&gt; [:10 :20 :30])</pre></td></tr><tr><td class="docs"><p>Apply the function f :
  - to the map of unsorted parameters args with the order of the arglists.
  - to the vector of sorted parameters.</p>
</td><td class="codes"><pre class="brush: clojure">(defn apply-fn
  ([f v-arglists m-args]
     (apply-fn f (parameters v-arglists m-args)))
  ([f v-args]
     (apply (resolve-str f) v-args)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;apply-fn&quot;
  (apply-fn :fq-fn :arglists :args) =&gt; :some-res
  (provided
    (parameters :arglists :args) =&gt; :parameter-in-order
    (apply-fn :fq-fn :parameter-in-order) =&gt; :some-res))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;apply-fn&quot;
  (apply-fn &quot;clojure.core/-&quot;
            [['x] ['x 'y]]
            {'y 10 'x 5}) =&gt; -5)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;apply-fn&quot;
  (apply-fn &quot;clojure.core/-&quot; [5 10]) =&gt; -5)</pre></td></tr><tr><td class="docs"><p>Load the file into a list</p>
</td><td class="codes"><pre class="brush: clojure">(defn- load-file-ns 
  [f]
  (split (slurp f) #&quot;\n&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact
  (load-file-ns &quot;namespaces-test-to-load&quot;) =&gt; [&quot;fnx.meta.example&quot; &quot;fnx.meta.example2&quot;])</pre></td></tr><tr><td class="docs"><p>Get the namespaces from the file namespaces-to-load</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-fq-fn! 
  ([] (load-fq-fn! &quot;namespaces-to-load&quot;))
  ([f]
     (map (comp fun-str str) (mapcat #(ns-public-fn (symbol %)) (load-file-ns f)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact
  (load-fq-fn! :file) =&gt; (contains
                           [&quot;fnx.meta.example/one-arg-fn&quot;
                            &quot;fnx.meta.example/hello-noir&quot;
                            &quot;fnx.meta.example/two-arg-fn&quot;
                            &quot;fnx.meta.example2/hello&quot;
                            &quot;fnx.meta.example2/three-arg-fn&quot;] :in-any-order)
  (provided
    (load-file-ns :file) =&gt; [&quot;fnx.meta.example&quot; &quot;fnx.meta.example2&quot;]))</pre></td></tr><tr><td class="docs"><p>Given a namespace, return the namespace's 'parent-ns'</p>
</td><td class="codes"><pre class="brush: clojure">(defn- parent-ns 
  [n]
  (when n
      (let [r (split n #&quot;\.&quot;)]
        (if (&lt;= 2 (count r)) (join &quot;.&quot; (butlast r)) nil))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;parent-ns&quot;
  (parent-ns nil) =&gt; nil
  (parent-ns &quot;foo.aws.extra&quot;) =&gt; &quot;foo.aws&quot;
  (parent-ns &quot;foo.aws&quot;) =&gt; &quot;foo&quot;
  (parent-ns &quot;foo&quot;) =&gt; nil)</pre></td></tr><tr><td class="docs"><p>Given a fully qualified function name, return a namespace</p>
</td><td class="codes"><pre class="brush: clojure">(defn- nsp 
  [f]
  (first (split f #&quot;/&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;nsp&quot;
  (nsp &quot;fnx.meta/expose&quot;) =&gt; &quot;fnx.meta&quot;)</pre></td></tr><tr><td class="docs"><p>Given a namespace, return the next namespace's depth</p>
</td><td class="codes"><pre class="brush: clojure">(defn- children-ns 
  [n vc]
  (if-not n
    (distinct (map #(first (split % #&quot;\.&quot;)) vc))
    (remove #{n} ((group-by #(.contains % n) vc) true))))</pre></td></tr><tr><td class="docs"><p>Given a namespace, returns its level.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- level 
  [ns]
  (count (split ns #&quot;\.&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;level&quot;
  (level &quot;foo&quot;)  =&gt; 1
  (level &quot;foo.aws&quot;)  =&gt; 2
  (level &quot;foo.aws.ec2&quot;) =&gt; 3)</pre></td></tr><tr><td class="docs"><p>Given a namespace, returns the nth level</p>
</td><td class="codes"><pre class="brush: clojure">(defn- nth-level 
  [n ns]
  (if (zero? n)
    nil
    (join #&quot;.&quot; (take n (split ns #&quot;\.&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;nth-level&quot;
  (nth-level 0 &quot;foo.aws&quot;) =&gt; nil
  (nth-level 1 &quot;foo.aws&quot;) =&gt; &quot;foo&quot;
  (nth-level 2 &quot;foo.aws.ec2&quot;) =&gt; &quot;foo.aws&quot;)</pre></td></tr><tr><td class="docs"><p>Given a namespace, return the next namespace's depth</p>
</td><td class="codes"><pre class="brush: clojure">(defn- children-ns 
  [n sc]
  (if n
    (let [l (level n)]
      (remove #{n} ((group-by #(.contains % n) (distinct (map #(nth-level (inc l) %) sc))) true)))
    (distinct (map #(nth-level 1 %) sc))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;IT - children-ns&quot;
  (children-ns nil #{&quot;foo&quot; &quot;foo.aws&quot; &quot;bar.other&quot; &quot;foo.ec2&quot;}) =&gt; (contains  [&quot;foo&quot; &quot;bar&quot;] :in-any-order)
  (children-ns &quot;foo&quot; #{&quot;foo&quot; &quot;foo.aws&quot; &quot;bar.other&quot; &quot;foo.ec2&quot;}) =&gt; (contains [&quot;foo.aws&quot; &quot;foo.ec2&quot;] :in-any-order)
  (children-ns &quot;bar.aws&quot; #{&quot;bar&quot; &quot;bar.aws.ec2.s3&quot; &quot;bar.aws.ec&quot; &quot;bar.aws.ec2.s4&quot;}) =&gt; (contains [&quot;bar.aws.ec2&quot; &quot;bar.aws.ec&quot;] :in-any-order)
  (children-ns &quot;foo&quot; #{}) =&gt; [])</pre></td></tr><tr><td class="docs"><p>Given a list of functions, returns the map of keypair ns-fn</p>
</td><td class="codes"><pre class="brush: clojure">(defn- map-namespaces 
  [vfn]
  (group-by nsp vfn))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;map-namespaces&quot;
  (map-namespaces [:fq-fn1 :fq-fn3 :fq-fn2 :fq-fn4]) =&gt; {:foo [:fq-fn1 :fq-fn2]
                                                         :bar [:fq-fn3]
                                                         :foobar [:fq-fn4]}
  (provided
    (nsp :fq-fn1) =&gt; :foo
    (nsp :fq-fn2) =&gt; :foo
    (nsp :fq-fn3) =&gt; :bar
    (nsp :fq-fn4) =&gt; :foobar))</pre></td></tr><tr><td class="docs"><p>Given a list of namespaces, returns the list of all namespace levels</p>
</td><td class="codes"><pre class="brush: clojure">(defn all-ns-levels 
  [lns]
  (let [max-level (apply max (map level lns))]
    (set (filter (comp not nil?)
                 (mapcat #(for [x (range (inc max-level))]
                            (nth-level x %))
                         lns)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;all-ns-levels&quot;
  (all-ns-levels #{&quot;foo.meta.expose&quot; &quot;foo.bar.ec2&quot;}) =&gt; (exactly #{&quot;foo.meta.expose&quot;
                                                                   &quot;foo&quot;
                                                                   &quot;foo.bar&quot;
                                                                   &quot;foo.meta&quot;
                                                                   &quot;foo.bar.ec2&quot;}) :in-any-order)</pre></td></tr><tr><td class="docs"><p>Load some namespaces from a list of fully qualified functions into the following example map:
  {nil              [nil       ["foo" "bar"]                  []]
   "foo"          [nil       ["foo.aws"]                      []]
   "bar"          [nil       ["bar.file"]                     []]
   "foo.aws"      ["foo"     ["foo.aws.ec2" "foo.aws.s3"] ["foo.aws/describe-region"]]
   "foo.aws.ec2"  ["foo.aws" []                               ["foo.aws.ec2/list-ami"]]
   "foo.aws.s3"   ["foo.aws" []                               ["foo.aws.s3/delete-buckets"]]
   "bar.file"     ["bar"     []                               ["bar.file/ls"]]}</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-map-ns
  [vfn]
  (let [m (map-namespaces vfn)
        k (all-ns-levels (keys m))]
    (reduce (fn [o n] (assoc o n [(parent-ns n) (children-ns n k) (m n)])) {} (concat [nil] k))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;load-map-ns&quot;
  (load-map-ns [:fq-fn1 :fq-fn2 :fq-fn3]) =&gt; {nil [nil [:foo :bar] []]
                                               :foo [nil [] [:fq-fn1 :fq-fn2]]
                                               :bar [nil [] [:fq-fn3]]}
  (provided
    (map-namespaces [:fq-fn1 :fq-fn2 :fq-fn3]) =&gt; {nil []
                                                   :foo [:fq-fn1 :fq-fn2]
                                                   :bar [:fq-fn3]}
    (all-ns-levels [nil :foo :bar]) =&gt; [:foo :bar]
    (parent-ns nil) =&gt; nil
    (parent-ns :foo) =&gt; nil
    (parent-ns :bar) =&gt; nil
    (children-ns nil [:foo :bar]) =&gt; [:foo :bar]
    (children-ns :foo [:foo :bar]) =&gt; []
    (children-ns :bar [:foo :bar]) =&gt; []))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;IT - load-map-ns&quot;
  (load-map-ns [&quot;foo/expose&quot;
                &quot;bar/ls&quot;
                &quot;bar.test.level3/cucoo&quot;
                &quot;foo.aws/list-ami&quot;
                &quot;foo.aws/list-regions&quot;
                &quot;foo.meta/run&quot; &quot;foo.aws.ec2/test&quot;]) =&gt;
  {&quot;foo.aws.ec2&quot;     [&quot;foo.aws&quot;    '()                     [&quot;foo.aws.ec2/test&quot;]]
   &quot;foo.aws&quot;         [&quot;foo&quot;        '(&quot;foo.aws.ec2&quot;)        [&quot;foo.aws/list-ami&quot; &quot;foo.aws/list-regions&quot;]]
   &quot;bar&quot;             [nil          '(&quot;bar.test&quot;)           [&quot;bar/ls&quot;]]
   &quot;bar.test.level3&quot; [&quot;bar.test&quot;   '()                     [&quot;bar.test.level3/cucoo&quot;]]
   &quot;foo.meta&quot;        [&quot;foo&quot;        '()                     [&quot;foo.meta/run&quot;]]
   &quot;bar.test&quot;        [&quot;bar&quot;        '(&quot;bar.test.level3&quot;)    nil]
   &quot;foo&quot;             [nil          '(&quot;foo.meta&quot; &quot;foo.aws&quot;) [&quot;foo/expose&quot;]]
   nil               [nil          '(&quot;foo&quot; &quot;bar&quot;)          nil]})</pre></td></tr><tr><td class="docs"><p>A function to extract the metadata from a string that represents a fully qualified function.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fn-meta 
  [f]
  (let [m (meta (resolve-str f))]
    {:doc (:doc m)
     :fname f
     :arglists (:arglists m)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;fn-meta&quot;
  (fn-meta &quot;fnx.meta.example/one-arg-fn&quot;) =&gt; '{:doc &quot;A public fn with one arg, should be listed&quot;
                                               :fname &quot;fnx.meta.example/one-arg-fn&quot;
                                               :arglists [[x]]})</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.api" name="one.sample.api"><h1 class="project-name">one.sample.api</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>The server side of the sample application. Provides a simple API for
  updating an in-memory database.</p>
</td><td class="codes"><pre class="brush: clojure">(ns one.sample.api
  (:use [compojure.core :only (defroutes POST)]
        [fnx.meta.expose :only [load-map-ns load-fq-fn! fn-meta apply-fn]]
        [midje.sweet]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce ^:private next-id (atom 0))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce ^:dynamic *database* (atom #{}))</pre></td></tr><tr><td class="docs"><p>Multimethod to handle incoming API calls. Implementations are
  selected based on the :fn key in the data sent by the client.
  Implementation are called with whatever data struture the client
  sends (which will already have been read into a Clojure value) and
  can return any Clojure value. The value the implementation returns
  will be serialized to a string before being sent back to the client.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti remote
  :fn)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod remote :default [data]
  {:status :error :message &quot;Unknown endpoint.&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod remote :add-name [data]
  (let [n (-&gt; data :args :name)
        response {:exists (contains? @*database* n)}]
    (swap! *database* conj n)
    response))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod remote :load-map-ns [data]
  (let [response {:res (load-map-ns (load-fq-fn!))}]
    response))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;:load-map-ns&quot;
  (remote {:fn :load-map-ns
           :args {:fq-fn :fully-qualified-fn-name}}) =&gt; {:res :output-result}
  (provided
    (load-fq-fn!) =&gt; :some-fully-qualified-fns
    (load-map-ns :some-fully-qualified-fns) =&gt; :output-result))</pre></td></tr><tr><td class="docs"><p>Remote access to retrieve the map of metadata for the function fnxs.</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod remote :load-map-meta-fn [data]
  (let [fname (-&gt; data :args :fq-fn)
        response {:meta-fn (fn-meta fname)}]
    response))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;:load-map-meta-fn&quot;
  (remote {:fn :load-map-meta-fn
           :args {:fq-fn :fully-qualified-fn-name}}) =&gt; {:meta-fn :output-result}
  (provided
    (fn-meta :fully-qualified-fn-name) =&gt; :output-result))</pre></td></tr><tr><td class="docs"><p>Remote access to apply a function to its arguments</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod remote :apply-fn [data]
  (let [meta-fn (-&gt; data :args :meta-fn)
        args (-&gt; data :args :args)
        fname (:fname meta-fn)
        arglists (:arglists meta-fn)]
    {:res (apply-fn fname arglists args)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;apply-fn&quot;
  (remote {:fn :apply-fn
           :args {:meta-fn {:fname :real-fq-fn
                            :arglists :some-arglists}
                  :args :some-real-map-with-args}}) =&gt; {:res :output-result}
  (provided
    (apply-fn :real-fq-fn
              :some-arglists
              :some-real-map-with-args) =&gt; :output-result))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;IT - no order needed&quot;
  (remote {:fn :apply-fn
           :args {:meta-fn {:fname &quot;clojure.core/+&quot;
                            :arglists [['x 'y]]}
                  :args {'x 1
                         'y 2} }}) =&gt; {:res 3})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fact &quot;IT - order needed&quot;
  (remote {:fn :apply-fn
           :args {:meta-fn {:fname &quot;clojure.core/-&quot;
                            :arglists [['x 'y]]}
                  :args {'y 1
                         'x 2} }}) =&gt; {:res 1})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defroutes remote-routes
  (POST &quot;/remote&quot; {{data &quot;data&quot;} :params}
        (pr-str
         (remote
          (binding [*read-eval* false]
            (read-string data))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.config" name="one.sample.config"><h1 class="project-name">one.sample.config</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Contains configuration for the sample application.</p>
</td><td class="codes"><pre class="brush: clojure">(ns one.sample.config
  (:require [net.cgrand.enlive-html :as html]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- production-transform [h]
  (html/transform h
                  [:ul#navigation]
                  (html/substitute (html/html-snippet ))))</pre></td></tr><tr><td class="docs"><p>Configuration for the sample application.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  config {:src-root &quot;src&quot;
          :app-root &quot;src/app/cljs&quot;
          :top-level-package &quot;one&quot;
          :js &quot;public/javascripts&quot;
          :dev-js-file-name &quot;main.js&quot;
          :prod-js-file-name &quot;mainp.js&quot;
          :dev-js [&quot;goog.require('one.sample.core');&quot;
                   &quot;goog.require('one.sample.model');&quot;
                   &quot;goog.require('one.sample.controller');&quot;
                   &quot;goog.require('one.sample.history');&quot;
                   &quot;goog.require('one.sample.logging');&quot;
                   &quot;one.sample.core.start();one.sample.core.repl();&quot;]
          :prod-js [&quot;one.sample.core.start();&quot;]
          :reload-clj [&quot;/one/host_page&quot;
                       &quot;/one/reload&quot;
                       &quot;/one/templates&quot;
                       &quot;/one/sample/api&quot;
                       &quot;/one/sample/config&quot;
                       &quot;/one/sample/dev_server&quot;
                       &quot;/fnx/meta/expose&quot;
                       &quot;/fnx/meta/example&quot;
                       &quot;/fnx/meta/example2&quot;]
          :prod-transform production-transform})</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.dev-server" name="one.sample.dev-server"><h1 class="project-name">one.sample.dev-server</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Serve a friendly ClojureScript environment with code reloading and
   the ClojureScript application in both development and advanced
   compiled mode.</p>
</td><td class="codes"><pre class="brush: clojure">(ns one.sample.dev-server
  (:use [ring.adapter.jetty :only (run-jetty)]
        [ring.middleware.file :only (wrap-file)]
        [ring.middleware.file-info :only (wrap-file-info)]
        [ring.middleware.params :only (wrap-params)]
        [ring.middleware.stacktrace :only (wrap-stacktrace)]
        [ring.util.response :only (file-response)]
        [compojure.core :only (defroutes GET POST ANY)]
        [cljs.repl :only (repl)]
        [cljs.repl.browser :only (repl-env)]
        [one.templates :only (load-html apply-templates render)]
        [one.host-page :only (application-host)]
        [one.sample.api :only (remote-routes)]
        [one.sample.config])
  (:require [net.cgrand.enlive-html :as html]
            [one.reload :as reload])
  (:import java.io.File))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- environment [uri]
  (if (= uri &quot;/development&quot;) :development :production))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- make-host-page [request]
  {:status 200
   :headers {&quot;Content-Type&quot; &quot;text/html; charset=utf-8&quot;}
   :body (application-host config (environment (:uri request)))})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defroutes app-routes
  remote-routes
  (GET &quot;/development&quot; request (make-host-page request))
  (GET &quot;/production&quot; request (make-host-page request) )
  (GET &quot;/design*&quot; {{file :*} :route-params}
       (when (.endsWith file &quot;.html&quot;)
         (load-html (.substring file 1))))
  (ANY &quot;*&quot; request (file-response &quot;404.html&quot; {:root &quot;public&quot;})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- js-encoding [handler]
  (fn [request]
    (let [{:keys [headers body] :as response} (handler request)]
      (if (and (= (get headers &quot;Content-Type&quot;) &quot;text/javascript&quot;)
               (= (type body) File))
        (assoc-in response [:headers &quot;Content-Type&quot;]
                  &quot;text/javascript; charset=utf-8&quot;)
        response))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- rewrite-design-uris [handler]
  (fn [{:keys [uri] :as request}]
    (if (some true? (map #(.startsWith uri (str &quot;/design/&quot; %))
                         [&quot;css&quot; &quot;javascripts&quot; &quot;images&quot; &quot;js&quot; &quot;favicon.ico&quot;]))
      (handler (assoc request :uri (.substring uri 7)))
      (handler request))))</pre></td></tr><tr><td class="docs"><p>Parse a string into a seq of Enlive nodes.</p>

<p>We need to use this instead of Enlive's html-snippet, because
html-snippet throws away the doctype</p>
</td><td class="codes"><pre class="brush: clojure">(defn- html-parse
  [s]
  (html/html-resource (java.io.StringReader. s)))</pre></td></tr><tr><td class="docs"><p>Accepts the selected menu (a keyword) and the response and returns
  an updated response body with the correct menu activated.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- active-menu-transform
  [menu response]
  (assoc response
    :body (render (html/transform (html-parse (:body response))
                                  [:ul#navigation (keyword (str &quot;li.&quot; (name menu)))]
                                  (html/add-class &quot;active&quot;)))))</pre></td></tr><tr><td class="docs"><p>Middleware which will highlight the current active menu item.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- set-active-menu
  [handler]
  (fn [request]
    (let [response (handler request)
          uri (:uri request)]
      (cond (= uri &quot;/&quot;) (active-menu-transform :home response)
            (and (.startsWith uri &quot;/design&quot;) (.endsWith uri &quot;.html&quot;)) (active-menu-transform :design response)
            (= uri &quot;/development&quot;) (active-menu-transform :development response)
            (= uri &quot;/production&quot;) (active-menu-transform :production response)
            :else response))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private app (-&gt; app-routes
                       (reload/watch-cljs config)
                       (wrap-file &quot;public&quot;)
                       rewrite-design-uris
                       wrap-file-info
                       apply-templates
                       js-encoding
                       wrap-params
                       set-active-menu
                       wrap-stacktrace
                       (reload/reload-clj (:reload-clj config))))</pre></td></tr><tr><td class="docs"><p>Start the development server on port 8080.</p>
</td><td class="codes"><pre class="brush: clojure">(defn run-server
  []
  (run-jetty (var app) {:join? false :port 8080}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.prod-server" name="one.sample.prod-server"><h1 class="project-name">one.sample.prod-server</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Production server serves the backend API. This is only required if
  there is a backend API.</p>
</td><td class="codes"><pre class="brush: clojure">(ns one.sample.prod-server
  (:use [ring.adapter.jetty :only (run-jetty)]
        [ring.middleware.file :only (wrap-file)]
        [ring.middleware.file-info :only (wrap-file-info)]
        [ring.middleware.params :only (wrap-params)]
        [ring.util.response :only (file-response)]
        [compojure.core :only (defroutes ANY)]
        [one.sample.api :only (remote-routes)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private root &quot;out/public&quot;)</pre></td></tr><tr><td class="docs"><p>HACK: Something about the defroutes below requires that the
out/public directory exist, or we get a compile error.</p>
</td><td class="codes"><pre class="brush: clojure">(.mkdirs (java.io.File. &quot;out/public&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defroutes app-routes
  remote-routes
  (-&gt; (ANY &quot;*&quot; request (file-response &quot;404.html&quot; {:root root}))
      (wrap-file root)
      wrap-file-info))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private app (-&gt; app-routes
                       wrap-params))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn run-server []
  (let [port (Integer/parseInt (get (System/getenv) &quot;PORT&quot; &quot;8080&quot;))]
    (run-jetty (var app) {:join? false :port port})))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.repl" name="one.sample.repl"><h1 class="project-name">one.sample.repl</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>The starting namespace for the project. This is the namespace that
  users will land in when they start a Clojure REPL. It exists to
  provide convenience functions like 'go' and 'dev-server'.</p>
</td><td class="codes"><pre class="brush: clojure">(ns one.sample.repl
  (:use [clojure.repl])
  (:require [one.tools :as tools]
            [one.sample.dev-server :as dev]
            [clojure.java.browse :as browse]))</pre></td></tr><tr><td class="docs"><p>Start a browser-connected REPL and launch a browser to talk to it.</p>
</td><td class="codes"><pre class="brush: clojure">(defn go
  []
  (dev/run-server)
  (future (Thread/sleep 3000)
          (browse/browse-url &quot;http://localhost:8080/development&quot;))
  (tools/cljs-repl))</pre></td></tr><tr><td class="docs"><p>Start the development server and open the host application in the
  default browser.</p>
</td><td class="codes"><pre class="brush: clojure">(defn dev-server
  []
  (dev/run-server)
  (future (Thread/sleep 3000)
          (browse/browse-url &quot;http://localhost:8080&quot;)))</pre></td></tr><tr><td class="docs"><p>Start a ClojureScript REPL.</p>

<p>This is a convenience function so that people can start a CLJS REPL
without having to type in (tools/cljs-repl)</p>
</td><td class="codes"><pre class="brush: clojure">(defn cljs-repl
  []
  (tools/cljs-repl))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(println)
(println &quot;Type (go) to launch the development server and setup a browser-connected REPL.&quot;)
(println &quot;Type (dev-server) to launch only the development server.&quot;)
(println)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#script.build" name="script.build"><h1 class="project-name">script.build</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Contains a -main function which builds the production artifacts for
  the project.</p>
</td><td class="codes"><pre class="brush: clojure">(ns script.build
  (:require [clojure.java.io :as io]
            [one.tools :as tools]
            [one.sample.config :as config]))</pre></td></tr><tr><td class="docs"><p>Compile ClojureScript sources and output them as well as all static
  resources to the out/public directory.</p>
</td><td class="codes"><pre class="brush: clojure">(defn -main
  []
  (println &quot;Creating out/public...&quot;)
  (.mkdir (io/file &quot;out&quot;))
  (tools/copy-recursive-into &quot;public&quot; &quot;out&quot;)
  (tools/delete &quot;out/public/index.html&quot;
                &quot;out/public/design.html&quot;
                &quot;out/public/javascripts&quot;)
  (.mkdir (io/file &quot;out/public/javascripts&quot;))
  (println &quot;Create advanced compiled JavaScript...&quot;)
  (tools/build-project config/config))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#script.serve" name="script.serve"><h1 class="project-name">script.serve</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provides a -main function which will start the production server.</p>
</td><td class="codes"><pre class="brush: clojure">(ns script.serve
  (:require [one.sample.prod-server :as prod]))</pre></td></tr><tr><td class="docs"><p>Start the production server which serves the content from
  out/public as well as the sample application's API.</p>
</td><td class="codes"><pre class="brush: clojure">(defn -main
  []
  (prod/run-server))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.snippets" name="one.sample.snippets"><h1 class="project-name">one.sample.snippets</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Macros for including HTML snippets in the ClojureScript application
  at compile time.</p>
</td><td class="codes"><pre class="brush: clojure">(ns one.sample.snippets
  (:use [one.templates :only (render)])
  (:require [net.cgrand.enlive-html :as html]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- snippet [file id]
  (render (html/select (html/html-resource file) id)))</pre></td></tr><tr><td class="docs"><p>Expands to a map of HTML snippets which are extracted from the
  design templates.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro snippets
  []
  {:form (snippet &quot;form.html&quot; [:div#form])
   :greeting (snippet &quot;greeting.html&quot; [:div#greeting])
   :fn-display (snippet &quot;fn-form.html&quot; [:div#fn-display])
   :ns-nav (snippet &quot;ns-nav.html&quot; [:div#ns-nav])
   :spinner (snippet &quot;spinner.html&quot; [:div#spinner])
   :prev (snippet &quot;prev.html&quot; [:div#prev])})</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#leiningen.bootstrap" name="leiningen.bootstrap"><h1 class="project-name">leiningen.bootstrap</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Bootstrap the project by running lein deps and lein git-deps.</p>
</td><td class="codes"><pre class="brush: clojure">(ns leiningen.bootstrap
  (:use [leiningen.git-deps :only [git-deps]]
        [leiningen.core :only [default-repos]]
        [leiningen.deps :only [deps]]
        [leiningen.util.maven :only [container make-remote-artifact
                                     make-remote-repo make-local-repo]])
  (:import (org.apache.maven.artifact.resolver ArtifactResolver)))</pre></td></tr><tr><td class="docs"><p>There is a bug in Leiningen 1.6.2 which requires that you have
Clojure 1.2.1 in the local maven repository when you are working on a
Clojure 1.3 project. If the first project that someone works on
with Leiningen is a Clojure 1.3 based project then they will
encounter this problem.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A lot of people have run into this with ClojureScript One so we
have added a workaround.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Leiningen includes an <code>install</code> task which, for some unknown reason,
takes a long time to run. Below, we have extracted just the part
of that task that we need to get a dependency from a maven repository.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Download a dependency from a maven repository.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- standalone-download
  [name group version]
  (.resolveAlways (.lookup container ArtifactResolver/ROLE)
                  (make-remote-artifact name group version)
                  (map make-remote-repo default-repos)
                  (make-local-repo)))</pre></td></tr><tr><td class="docs"><p>Bootstrap the project by running lein deps and lein git-deps.</p>
</td><td class="codes"><pre class="brush: clojure">(defn bootstrap
  [project]
  ;; Workarond for Leiningen 1.6.2 bug. Ensure that we have Clojure 1.2.1 in
  ;; the local maven repository.
  (standalone-download &quot;clojure&quot; &quot;org.clojure&quot; &quot;1.2.1&quot;)
  (git-deps project)
  (deps project))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#leiningen.git-deps" name="leiningen.git-deps"><h1 class="project-name">leiningen.git-deps</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>How this works: It clones projects into .lein-git-deps/<whatever>.
  If the directory already exists, it does a git pull and git checkout.</p>
</td><td class="codes"><pre class="brush: clojure">(ns leiningen.git-deps
  (:require [clojure.java.shell :as sh]
            [clojure.java.io :as io]
            [clojure.string :as string]))</pre></td></tr><tr><td class="docs"><p>The directory into which dependencies will be cloned.</p>

<p>Why, you might ask, are we using str here instead of simply def'ing
the var to a string directly? The answer is that we are working
around a bug in marginalia where it can't tell the difference
between the string that's the value for a def and a docstring. It
will hopefully be fixed RSN, because this makes us feel dirty.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true
       :doc }
  git-deps-dir (str &quot;.lein-git-deps&quot;))</pre></td></tr><tr><td class="docs"><p>Return true if the specified directory exists.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- directory-exists?
  [dir]
  (.isDirectory (io/file dir)))</pre></td></tr><tr><td class="docs"><p>Given a git URL, return the directory it would clone into by default.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- default-clone-dir
  [uri]
  (string/join &quot;.&quot; (-&gt; uri
                       (string/split #&quot;/&quot;)
                       (last)
                       (string/split #&quot;\.&quot;)
                       butlast)))</pre></td></tr><tr><td class="docs"><p>Run a command, throwing an exception if it fails, returning the
  result as with clojure.java.shell/sh.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- exec
  [&amp; args]
  (let [{:keys [exit out err] :as result} (apply sh/sh args)]
    (if (zero? exit)
      result
      (throw
       (Exception.
        (format &quot;Command %s failed with exit code %s\n%s\n%s&quot;
                (apply str (interpose &quot; &quot; args))
                exit
                out
                err))))))</pre></td></tr><tr><td class="docs"><p>Clone the git repository at url into dir-name while working in
  directory working-dir.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- git-clone
  [url dir-name working-dir]
  (apply exec (remove nil? [&quot;git&quot; &quot;clone&quot; url (str dir-name) :dir working-dir])))</pre></td></tr><tr><td class="docs"><p>Check out the specified commit in dir.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- git-checkout
  [commit dir]
  (println &quot;Running git checkout &quot; commit &quot; in &quot; (str dir))
  (exec &quot;git&quot; &quot;checkout&quot; commit :dir dir))</pre></td></tr><tr><td class="docs"><p>Return true if the git repository in dir has HEAD detached.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- detached-head?
  [dir]
  (let [{out :out} (exec &quot;git&quot; &quot;branch&quot; &quot;--color=never&quot; :dir dir)
        lines (string/split-lines out)
        current-branch (first (filter #(.startsWith % &quot;*&quot;) lines))]
    (when-not current-branch
      (throw (Exception. &quot;Unable to determine current branch&quot;)))
    (= current-branch &quot;* (no branch)&quot;)))</pre></td></tr><tr><td class="docs"><p>Run 'git-pull' in directory dir, but only if we're on a branch. If
  HEAD is detached, we only do a fetch, not a full pull.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- git-pull
  [dir]
  (println &quot;Running git pull on &quot; (str dir))
  (if (detached-head? dir)
    (do
      (println &quot;Not on a branch, so fetching instead of pulling.&quot;)
      (exec &quot;git&quot; &quot;fetch&quot; :dir dir))
    (exec &quot;git&quot; &quot;pull&quot; :dir dir)))</pre></td></tr><tr><td class="docs"><p>A leiningen task that will pull dependencies in via git.</p>

<p>  Dependencies should be listed in project.clj under the
  :git-dependencies key in one of these three forms:</p>

<pre><code>:git-dependencies [;; First form: just a URL.
                   ["https://github.com/foo/bar.git"]

                   ;; Second form: A URL and a ref, which can be anything
                   ;; you can specify for 'git checkout', like a commit id
                   ;; or a branch name.
                   ["https://github.com/foo/baz.git"
                    "329708b"]

                   ;; Third form: A URL, a commit, and a map
                   ["https://github.com/foo/quux.git"
                    "some-branch"
                    {:dir "alternate-directory"}]]
</code></pre>
</td><td class="codes"><pre class="brush: clojure">(defn git-deps
  [project]
  (when-not (directory-exists? git-deps-dir)
    (.mkdir (io/file git-deps-dir)))
  (doseq [dep (:git-dependencies project)]
    (println &quot;Setting up dependency for &quot; dep)
    (let [[dep-url commit {clone-dir-name :dir}] dep
          commit (or commit &quot;master&quot;)
          clone-dir-name (or clone-dir-name (default-clone-dir dep-url))
          clone-dir (io/file git-deps-dir clone-dir-name)]
      (if (directory-exists? clone-dir)
        (git-pull clone-dir)
        (git-clone dep-url clone-dir-name git-deps-dir))
      (git-checkout commit clone-dir))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.config" name="one.config"><h1 class="project-name">one.config</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Convenience functions for working with configuration data.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.config)</pre></td></tr><tr><td class="docs"><p>Given a configuration map, return output directory options.</p>
</td><td class="codes"><pre class="brush: clojure">(defn cljs-build-opts
  [config]
  {:output-to (str (:js config) &quot;/&quot; (:dev-js-file-name config))
   :output-dir (str (:js config) &quot;/out&quot;)})</pre></td></tr><tr><td class="docs"><p>Given a configuration map, return the path to the production
  Javascript file.</p>
</td><td class="codes"><pre class="brush: clojure">(defn production-js
  [config]
  (str (:js config) &quot;/&quot; (:prod-js-file-name config)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.host-page" name="one.host-page"><h1 class="project-name">one.host-page</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Functions to create an HTML page that hosts a ClojureScript
  application.</p>
</td><td class="codes"><pre class="brush: clojure">(ns one.host-page
  (:use [one.templates :only (construct-html render)])
  (:require [net.cgrand.enlive-html :as html]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private script-snippet
  (html/html-snippet &quot;&lt;script type='text/javascript'&gt;&lt;/script&gt;&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- script
  [f]
  (html/transform script-snippet [:script] f))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- application-view
  [&amp; scripts]
  (html/transform (construct-html (html/html-resource &quot;application.html&quot;))
                  [:body]
                  (apply html/append scripts)))</pre></td></tr><tr><td class="docs"><p>Given a configuration map and an environment, return HTML (as a
  string) that can host a ClojureScript application. The environment
  must be either <code>:development</code> or <code>:production</code> - any other value results
  in an exception. The generated HTML is based on the contents of
  application.html, which is loaded as an Enlive resource.</p>

<p>  In production mode, the HTML (as a sequence of Enlive nodes) is
  transformed via the <code>:prod-transform</code> function from the config map.</p>

<p>  This function is normally called in two situations:</p>

<ol>
<li><p>From a Ring application to dynamically generate the application
 HTML.</p></li>
<li><p>From the build script to create static deployment artifacts.</p></li>
</ol>
</td><td class="codes"><pre class="brush: clojure">(defn application-host
  [config environment]
  (render
   (case environment
     :development
     (apply application-view (script (html/set-attr :src &quot;javascripts/out/goog/base.js&quot;))
            (script (html/set-attr :src &quot;javascripts/main.js&quot;))
            (map #(script (html/content %)) (:dev-js config)))
     :production
     (let [tfn (get config :prod-transform identity)]
       (tfn (apply application-view
                   (script (html/set-attr :src (str &quot;javascripts/&quot;
                                                    (:prod-js-file-name config))))
                   (map #(script (html/content %)) (:prod-js config))))))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.reload" name="one.reload"><h1 class="project-name">one.reload</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Contains functions which implement Clojure and ClojureScript code
  reloading.</p>

<p>  When any watched Clojure file changes, all watched Clojure files
  will be recompiled. If any ClojureScript file changes or if any
  template file changes, all ClojureScript files will be recompiled.</p>

<p>  Recompilation only happens on page reloads.</p>
</td><td class="codes"><pre class="brush: clojure">(ns one.reload
  (:use [cljs.closure :only (build)]
        [one.config])
  (:require [clojure.java.io :as io]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce ^:private
  last-compile (atom {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- any-modified
  [k files]
  (let [newest (apply max
                      (map #(.lastModified %) files))]
    (when (&gt; newest (get @last-compile k 0))
      newest)))</pre></td></tr><tr><td class="docs"><p>Return a seq of File objects that are descendants of dir that end
  with extension ext.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- descendants-ending-with
  [dir ext]
  (filter #(.endsWith (.getName %) ext) (file-seq (io/file dir))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- any-modified-cljs
  [dir k]
  (let [files (filter #(.isFile %) (into (descendants-ending-with dir &quot;.cljs&quot;)
                                         (file-seq (io/file &quot;templates&quot;))))]
    (any-modified k files)))</pre></td></tr><tr><td class="docs"><p>Ring middleware which watches dir for changes to ClojureScript
  source files and template HTML files. When changes are detected,
  recompiles only the ClojureScript and template files (not the
  Clojure files) using a build configuration derived from config.</p>
</td><td class="codes"><pre class="brush: clojure">(defn watch-cljs 
  [handler config]
  (fn [request]
    (let [k (:uri request)
          ts (any-modified-cljs (:src-root config) k)]
      (when ts
        (swap! last-compile assoc k ts)
        (let [build-opts (cljs-build-opts config)]
          (doseq [file (file-seq (io/file (str (:output-dir build-opts) &quot;/&quot;
                                               (:top-level-package config))))]
            (.setLastModified file 0))
          (build (:app-root config) (if (= (:uri request) &quot;/production&quot;)
                                      (assoc build-opts :optimizations :advanced
                                             :output-to (production-js config))
                                      build-opts)))))
    (handler request)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- any-modified-clj
  [files]
  (any-modified &quot;clj&quot;
                (map #(-&gt; (str % &quot;.clj&quot;)
                          (.substring 1)
                          io/resource
                          (.getFile)
                          io/file)
                     files)))</pre></td></tr><tr><td class="docs"><p>Ring middleware which watches a list of Clojure files for changes
  and recompiles all of them when any of the files change.</p>
</td><td class="codes"><pre class="brush: clojure">(defn reload-clj
  [handler files]
  (fn [request]
    (when-let [ts (any-modified-clj files)]
      (swap! last-compile assoc &quot;clj&quot; ts)
      (let [ns (ns-name *ns*)]
        (apply load files)))
    (handler request)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.templates" name="one.templates"><h1 class="project-name">one.templates</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Contains functions for combining HTML fragments into complete HTML documents.</p>
</td><td class="codes"><pre class="brush: clojure">(ns one.templates
  (:use net.cgrand.enlive-html)
  (:import java.io.File))</pre></td></tr><tr><td class="docs"><p>Given a seq of Enlive nodes, return the corresponding HTML string.</p>
</td><td class="codes"><pre class="brush: clojure">(defn render
  [t]
  (apply str (emit* t)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare construct-html)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- html-body [name]
  (:content (first (select (html-resource name) [:body]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- include-html [h]
  (let [includes (select h [:_include])]
    (loop [h h
           includes (seq includes)]
      (if includes
        (let [file (-&gt; (first includes) :attrs :file)
              include (construct-html (html-body file))]
          (recur (transform h [[:_include (attr= :file file)]] (substitute include))
                 (next includes)))
        h))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- maps [c] (filter map? c))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- replace-html [h c]
  (let [id (-&gt; c :attrs :id)
        tag (:tag c)
        selector (keyword (str (name tag) &quot;#&quot; id))]
    (transform h [selector] (substitute c))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- wrap-html [h]
  (let [within (seq (select h [:_within]))]
    (if within
      (let [file (-&gt; (first within) :attrs :file)
            outer (construct-html (html-resource file))
            content (maps (:content (first within)))]
        (loop [outer outer
               content (seq content)]
          (if content
            (recur (replace-html outer (first content)) (next content))
            outer)))
      h)))</pre></td></tr><tr><td class="docs"><p>Process a seq of Enlive nodes looking for <code>_include</code> and <code>_within</code> tags.
  Occurrences of <code>_include</code> are replaced by the resource to which they
  refer. The contents of <code>_within</code> tags are inserted into the resource
  to which they refer. <code>_within</code> is always the top-level tag in a file.
  <code>_include</code> can appear anywhere. Files with <code>_include</code> can reference
  files which themselves contain <code>_include</code> or <code>_within</code> tags, to an
  arbitrary level of nesting.</p>

<p>  For more information, see '<a href="https://github.com/brentonashworth/one/wiki/Design-and-templating">Design and Templating</a>' in the project
  wiki.</p>

<p>  Returns a seq of Enlive nodes.</p>
</td><td class="codes"><pre class="brush: clojure">(defn construct-html
  [nodes]
  (wrap-html (include-html nodes)))</pre></td></tr><tr><td class="docs"><p>Accept a file (a path to a resource on the classpath) and return a
  HTML string processed per construct-html.</p>
</td><td class="codes"><pre class="brush: clojure">(defn load-html
  [file]
  (render (construct-html (html-resource file))))</pre></td></tr><tr><td class="docs"><p>Ring middleware which intercepts files served from the public
  directory and applies templating.</p>
</td><td class="codes"><pre class="brush: clojure">(defn apply-templates
  [handler]
  (fn [request]
    (let [{:keys [headers body] :as response} (handler request)]
      (if (and (= (type body) File)
               (.endsWith (.getName body) &quot;.html&quot;))
        (let [new-body (render (construct-html (html-snippet (slurp body))))]
          {:status 200
           :headers {&quot;Content-Type&quot; &quot;text/html; charset=utf-8&quot;}
           :body new-body})
        response))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.test" name="one.test"><h1 class="project-name">one.test</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Support for evaluating ClojureScript code from Clojure tests.</p>
</td><td class="codes"><pre class="brush: clojure">(ns one.test
  (:refer-clojure :exclude [load-file])
  (:use [cljs.compiler :only (namespaces)]
        [cljs.repl :only (evaluate-form load-file load-namespace)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *eval-env*)</pre></td></tr><tr><td class="docs"><p>Evaluate a ClojureScript form within the given evaluation
  environment. The form will also be evaluated in the passed namespace
  which defaults to <code>'cljs.user</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn evaluate-cljs
  ([eval-env form]
     (evaluate-cljs eval-env 'cljs.user form))
  ([eval-env ns form]
     (let [env {:context :statement :locals {}}]
       (cond
        (and (seq? form) ('#{load-file clojure.core/load-file} (first form)))
        (load-file eval-env (second form))
        (and (seq? form) ('#{load-namespace} (first form)))
        (load-namespace eval-env (second form))
        :else
        (let [ret (evaluate-form eval-env
                                 (assoc env :ns (@namespaces ns))
                                 &quot;&lt;testing&gt;&quot;
                                 form
                                 (fn [x] `(cljs.core.pr-str ~x)))]
          (try (read-string ret)
               (catch Exception e
                 (if (string? ret)
                   ret
                   nil))))))))</pre></td></tr><tr><td class="docs"><p>Using evaluation environment <code>eval-env</code> evaluate form in namespace
  <code>ns</code> in the browser until <code>pred</code> applied to the result returns <code>true</code> or
  the timeout expires. If <code>pred</code> returns logical true, returns the
  result of <code>pred</code>. Throws <code>Exception</code> if the timeout (in milliseconds)
  has expired.</p>
</td><td class="codes"><pre class="brush: clojure">(defn cljs-wait-for*
  [eval-env pred ns form remaining]
  (if (pos? remaining)
    (if-let [result (pred (evaluate-cljs eval-env ns form))]
      result
      (do (Thread/sleep 10)
          (recur eval-env pred ns form (- remaining 10))))
    (throw (Exception.
            (str &quot;Form &quot;
                 form
                 &quot; did not satisfy predicate before the timeout expired.&quot;)))))</pre></td></tr><tr><td class="docs"><p>Expands to a call to <code>cljs-wait-for*</code> using <code>*eval-env*</code> as the
  evaluation environment and a timeout of roughly one minute.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro cljs-wait-for
  [pred ns form]
  `(cljs-wait-for* *eval-env* ~pred (quote ~ns) (quote ~form) 60000))</pre></td></tr><tr><td class="docs"><p>Ensure that that browser has completely loaded namespace ns. We
   need this because in some situations, we wind up trying to run code
   that depends on a namespace that isn't available yet, due to
   asynchrony in the browser. Returns true if the namespace loads
   within the specified timeout (roughly 60 seconds by default), and
   throws <code>Exception</code> otherwise.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ensure-ns-loaded
  ([eval-env ns] (ensure-ns-loaded eval-env ns 60000))
  ([eval-env ns remaining]
     (if (pos? remaining)
       (if (evaluate-cljs eval-env (list 'boolean ns))
         true
         (do (Thread/sleep 10)
             (recur eval-env ns (- remaining 10))))
       (throw (Exception. (str &quot;Namespace &quot; ns &quot; did not load before the timeout expired.&quot;))))))</pre></td></tr><tr><td class="docs"><p>Evaluate forms in namespace <code>ns</code> in the evaluation environment
  <code>*eval-env*</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defmacro cljs-eval
  [ns &amp; forms]
  `(do
     (ensure-ns-loaded *eval-env* (quote ~ns))
     ~@(map (fn [x] `(evaluate-cljs *eval-env* (quote ~ns) (quote ~x))) forms)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.tools" name="one.tools"><h1 class="project-name">one.tools</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Support for building deployment artifacts for a project.</p>
</td><td class="codes"><pre class="brush: clojure">(ns one.tools
  (:use [cljs.closure :only (build)]
        [one.host-page :only (application-host)]
        [one.config :only (cljs-build-opts production-js)]
        [cljs.repl :only (repl)]
        [cljs.repl.browser :only (repl-env)])
  (:require [clojure.java.io :as io]))</pre></td></tr><tr><td class="docs"><p>Emit both a JavaScript file containing the compiled ClojureScript
  application and the host HTML page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn build-project
  [config]
  (build (:app-root config) (assoc (cljs-build-opts config)
                              :optimizations :advanced
                              :output-to (str &quot;out/&quot; (production-js config))))
  (spit &quot;out/public/index.html&quot; (application-host config :production)))</pre></td></tr><tr><td class="docs"><p>Start a ClojureScript REPL which can connect to the development
  version of the application. The REPL will not work until the
  development page connects to it, so you will need to either open or
  refresh the development page after calling this function.</p>
</td><td class="codes"><pre class="brush: clojure">(defn cljs-repl
  []
  (repl (repl-env)))</pre></td></tr><tr><td class="docs"><p>Recursively copy the files in src to dest.</p>
</td><td class="codes"><pre class="brush: clojure">(defn copy-recursive-into
  [src dest]
  (doseq [file (remove #(.isDirectory %) (file-seq (io/file src)))]
    (let [dest-file (io/file dest file)]
      (.mkdirs (.getParentFile dest-file))
      (io/copy file dest-file))))</pre></td></tr><tr><td class="docs"><p>Delete one or more files or directories. Directories are recursively
  deleted.</p>
</td><td class="codes"><pre class="brush: clojure">(defn delete
  [&amp; paths]
  (doseq [path paths
          file (reverse (file-seq (io/file path)))]
    (.delete file)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#script.docs" name="script.docs"><h1 class="project-name">script.docs</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provides a <code>-main</code> function which will generate the documentation for
  the website, the documentation that you are viewing at this very
  moment.</p>
</td><td class="codes"><pre class="brush: clojure">(ns script.docs
  (:require [net.cgrand.enlive-html :as html]
            [clojure.java.io :as io]))</pre></td></tr><tr><td class="docs"><p>Accepts a relative path for an HTML file and returns the body
  content from that file.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- uberdoc-content
  [file]
  (-&gt; (io/file file)
      html/html-resource
      (html/select [:body])
      first
      :content))</pre></td></tr><tr><td class="docs"><p>Accepts the relative path for the documentation template file
  and the margenalia content and returns the documentation page for
  the website.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- docs
  [template marg]
  (-&gt; (io/file template)
      html/html-resource
      (html/transform [:div#marginalia-documentation]
                      (html/substitute marg))))</pre></td></tr><tr><td class="docs"><p>Create the documentation.html page for the website. Outputs this
  file as <code>docs/documentation.html</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn -main
  []
  (let [marg (uberdoc-content &quot;docs/uberdoc.html&quot;)
        docs (docs &quot;script/documentation.html&quot; marg)]
    (spit &quot;docs/documentation.html&quot;
          (apply str (html/emit* docs)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.animation" name="one.sample.animation"><h1 class="project-name">one.sample.animation</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Defines animations which are used in the sample
  application.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.sample.animation
  (:use [one.core :only (start)]
        [one.browser.animation :only (bind parallel serial play play-animation)]
        [domina :only (by-id set-html! set-styles! destroy-children! append! single-node)]
        [domina.xpath :only (xpath)])
  (:require [goog.dom.forms :as gforms]
            [goog.style :as style]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def form &quot;//div[@id='form']&quot;)
(def cloud &quot;//div[@id='greeting']&quot;)
(def label &quot;//label[@id='name-input-label']/span&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private
  form-in {:effect :fade :start 0 :end 1 :time 800})</pre></td></tr><tr><td class="docs"><p>Accepts the form and greeting view HTML and adds them to the
  page. Animates the form sliding in from above. This function must be
  run before any other view functions. It may be called from any state
  to reset the UI.</p>
</td><td class="codes"><pre class="brush: clojure">(defn initialize-views
  [form-html greeting-html]
  (let [content (xpath &quot;//div[@id='content']&quot;)]
    (destroy-children! content)
    (set-html! content form-html)
    (append! content greeting-html)
    ;; Required for IE8 to work correctly
    (style/setOpacity (single-node (xpath label)) 1)
    (set-styles! (xpath cloud) {:opacity &quot;0&quot; :display &quot;none&quot; :margin-top &quot;-500px&quot;})
    (set-styles! (by-id &quot;greet-button&quot;) {:opacity &quot;0.2&quot; :disabled true})
    (play form form-in {:after #(.focus (by-id &quot;name-input&quot;) ())})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Try it
  (initialize-views (:form one.sample.view/snippets)
                    (:greeting one.sample.view/snippets)))</pre></td></tr><tr><td class="docs"><p>------------- fnx ------------- </p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Accepts the form and greeting view HTML and adds them to the
  page. Animates the form sliding in from above. This function must be
  run before any other view functions. It may be called from any state
  to reset the UI.</p>
</td><td class="codes"><pre class="brush: clojure">(defn initialize-views-fnx
  [ns-nav fn-display spinner prev]
  (let [content-fnx (xpath &quot;//div[@id='content-fnx']&quot;)]
    (destroy-children! content-fnx)
    (append! content-fnx prev)
    (append! content-fnx ns-nav)
    (append! content-fnx fn-display)
    (append! content-fnx spinner)
    (set-styles! (by-id &quot;prev&quot;) {:display &quot;none&quot;})
    (set-styles! (by-id &quot;ns-nav&quot;) {:display &quot;none&quot;})
    (set-styles! (by-id &quot;fn-display&quot;) {:display &quot;none&quot;})
    (set-styles! (by-id &quot;spinner&quot;) {:display &quot;block&quot;
                                    :border &quot;1px solid black&quot;})))</pre></td></tr><tr><td class="docs"><p>------------- fnx ------------- </p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Move the passed input field label above the input field. Run when
  the field gets focus and is empty.</p>
</td><td class="codes"><pre class="brush: clojure">(defn label-move-up
  [label]
  (play label [{:effect :color :end &quot;#53607b&quot; :time 200}
               {:effect :slide :up 40 :time 200}]))</pre></td></tr><tr><td class="docs"><p>Make the passed input field label invisible. Run when the input
  field loses focus and contains a valid input value.</p>
</td><td class="codes"><pre class="brush: clojure">(defn label-fade-out
  [label]
  (play label {:effect :fade :end 0 :time 200}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def move-down [{:effect :fade :end 1 :time 200}
                {:effect :color :end &quot;#BBC4D7&quot; :time 200}
                {:effect :slide :down 40 :time 200}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def fade-in {:effect :fade :end 1 :time 400})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def fade-out {:effect :fade :end 0 :time 400})</pre></td></tr><tr><td class="docs"><p>Make the passed input field label visible and move it down into the
  input field. Run when an input field loses focus and is empty.</p>
</td><td class="codes"><pre class="brush: clojure">(defn label-move-down
  [label]
  (play label move-down))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Examples of label effects.
  
  (label-move-up label)
  (label-fade-out label)
  (label-move-down label)
  )</pre></td></tr><tr><td class="docs"><p>Move the form out of view and the greeting into view. Run when the
  submit button is clicked and the form has valid input.</p>
</td><td class="codes"><pre class="brush: clojure">(defn show-greeting
  []
  (let [e {:effect :fade :end 0 :time 500}]
    (play-animation #(parallel (bind form e)
                               (bind label e) ; Since the label won't fade in IE
                               (bind cloud
                                     {:effect :color :time 500} ; Dummy animation for delay purposes
                                     {:effect :fade-in-and-show :time 600}))
                    {:before #(gforms/setDisabled (by-id &quot;name-input&quot;) true)
                     ;; We need this next one because IE8 won't hide the button
                     :after #(set-styles! (by-id &quot;greet-button&quot;) {:display &quot;none&quot;})})))</pre></td></tr><tr><td class="docs"><p>Move the greeting cloud out of view and show the form. Run when the
  back button is clicked from the greeting view.</p>
</td><td class="codes"><pre class="brush: clojure">(defn show-form
  []
  (play-animation (serial (parallel (bind cloud {:effect :fade-out-and-hide :time 500})
                                    (bind form
                                          {:effect :color :time 300} ; Dummy animation for delay purposes
                                          form-in)
                                    (bind label fade-in move-down)))
                  {;; Because IE8 won't hide the button, we need to
                   ;; toggle it between displaying inline and none
                   :before #(set-styles! (by-id &quot;greet-button&quot;) {:display &quot;inline&quot;})
                   :after #(do
                             (gforms/setDisabled (by-id &quot;name-input&quot;) false)
                             (.focus (by-id &quot;name-input&quot;) ()))}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Switch between greeting and form views

  (label-move-up label)
  (show-greeting)
  (show-form)
  )</pre></td></tr><tr><td class="docs"><p>Accepts an element id for a button and disables it. Fades the
  button to 0.2 opacity.</p>
</td><td class="codes"><pre class="brush: clojure">(defn disable-button
  [id]
  (let [button (by-id id)]
    (gforms/setDisabled button true)
    (play button {:effect :fade :end 0.2 :time 400})))</pre></td></tr><tr><td class="docs"><p>Accepts an element id for a button and enables it. Fades the button
  to an opactiy of 1.</p>
</td><td class="codes"><pre class="brush: clojure">(defn enable-button
  [id]
  (let [button (by-id id)]
    (gforms/setDisabled button false)
    (play button fade-in)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Examples of all effects

  (initialize-views (:form one.sample.view/snippets)
                    (:greeting one.sample.view/snippets))
  (label-move-up label)
  (label-fade-out label)
  (show-greeting)
  (show-form)

  (disable-button &quot;greet-button&quot;)
  (enable-button &quot;greet-button&quot;)
  )</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.controller" name="one.sample.controller"><h1 class="project-name">one.sample.controller</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Respond to user actions by updating local and remote
  application state.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.sample.controller
  (:use [one.browser.remote :only (request)]
        [one.sample.model :only (state state-fnx)])
  (:require [cljs.reader :as reader]
            [clojure.browser.event :as event]
            [one.dispatch :as dispatch]
            [goog.uri.utils :as uri]))</pre></td></tr><tr><td class="docs"><p>Accepts a map containing information about an action to perform.</p>

<p>  Actions may cause state changes on the client or the server. This
  function dispatches on the value of the <code>:type</code> key and currently
  supports <code>:init</code>, <code>:form</code>, and <code>:greeting</code> actions.</p>

<p>  The <code>:init</code> action will initialize the appliation's state.</p>

<p>  The <code>:form</code> action will only update the status atom, setting its state
  to <code>:from</code>.</p>

<p>  The <code>:greeting</code> action will send the entered name to the server and
  update the state to <code>:greeting</code> while adding <code>:name</code> and <code>:exists</code>
  values to the application's state.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti action
  :type)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod action :init [_])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod action :form [_]
  (when-not (#{:form :init} (:state @state))
    (swap! state assoc :state :form)))</pre></td></tr><tr><td class="docs"><p>Get the name of the host which served this script.</p>
</td><td class="codes"><pre class="brush: clojure">(defn host
  []
  (uri/getHost (.toString window.location ())))</pre></td></tr><tr><td class="docs"><p>Accepts a function id (an identifier for this request), data (the
  data to send to the server) and a callback function which will be
  called if the transmission is successful. Perform an Ajax <code>POST</code>
  request to the backend API which sends the passed data to the
  server.</p>

<p>  A tranmission error will add an error message to the application's
  state.</p>
</td><td class="codes"><pre class="brush: clojure">(defn remote
  [f data on-success]
  (request f (str (host) &quot;/remote&quot;)
           :method &quot;POST&quot;
           :on-success #(on-success (reader/read-string (:body %)))
           :on-error #(swap! state assoc :error &quot;Error communicating with server.&quot;)
           :content (str &quot;data=&quot; (pr-str {:fn f :args data}))))</pre></td></tr><tr><td class="docs"><p>This is the success callback function which will be called when a
  request is successful. Accepts a name and a map of response data.
  Sets the current state to <code>:greeting</code> and adds the <code>:name</code> and
  <code>:exists</code> values to the application's state.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-name-callback
  [name response]
  (swap! state (fn [old]
                 (assoc (assoc old :state :greeting :name name)
                   :exists (boolean (:exists response))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod action :greeting [{name :name}]
  (remote :add-name {:name name} #(add-name-callback name %)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dispatch/react-to #{:init :form :greeting}
                   (fn [t d] (action (assoc d :type t))))</pre></td></tr><tr><td class="docs"><p>--------------- <fnx> ---------------</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Accepts a map containing information about an action to perform.</p>

<p>  Actions may cause state changes on the client or the server. This
  function dispatches on the value of the <code>:type</code> key and currently
  supports <code>:init</code>, <code>:ns-nav</code></p>

<p>  The <code>:init</code> action will fetch the ns hierarchy from the server and store it in the atom state.</p>

<p>  The <code>:ns-nav</code> action will navigate to a particular namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti action-fnx
  :type)</pre></td></tr><tr><td class="docs"><p>This is the success callback function which will be called when a
  request is successful. Accepts a map of response data.
  Sets the current state to <code>:ns-navigating</code> and adds the <code>:all-ns</code> and
  <code>:ns-nav</code> to the application's state.</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-ns-callback
  [response]
  (swap! state-fnx (fn [old]
                     (assoc old
                       :state :ns-navigating
                       :all-ns (response :res)
                       :ns-nav nil))))</pre></td></tr><tr><td class="docs"><p>Mock map of namespaces-fns, this is an example of what comes from the server.</p>
</td><td class="codes"><pre class="brush: clojure">(def all-ns 
  {nil            [nil       [&quot;foo&quot; &quot;bar&quot;]                []]
   &quot;foo&quot;          [nil       [&quot;foo.aws&quot;]                  []]
   &quot;bar&quot;          [nil       [&quot;bar.file&quot;]                 []]
   &quot;foo.aws&quot;      [&quot;foo&quot;     [&quot;foo.aws.ec2&quot; &quot;foo.aws.s3&quot;] [&quot;describe-region&quot;]]
   &quot;foo.aws.ec2&quot;  [&quot;foo.aws&quot; []                           [&quot;list-ami&quot;]]
   &quot;foo.aws.s3&quot;   [&quot;foo.aws&quot; []                           [&quot;delete-buckets&quot;]]
   &quot;bar.file&quot;     [&quot;bar&quot;     []                           [&quot;ls&quot;]]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod action-fnx :init [_]
  ;; event init to reset the state of the application and incidentally refresh the ui
  (reset! state-fnx {:state :init})
  ;; call the server to populate the namespaces
  (remote :load-map-ns {} #(add-ns-callback %)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod action-fnx :ns-clicked [{ns :ns}]
  ;; update the model with the new namespace
  (swap! state-fnx (fn [old]
                     (assoc old
                       :state :ns-navigating
                       :ns-nav ns))))</pre></td></tr><tr><td class="docs"><p>This is mock map, example of what comes from the server.</p>
</td><td class="codes"><pre class="brush: clojure">(def fn-meta-to-display
  {:fname &quot;fully.qualified.ns/some-function-to-display&quot;
   :arglists [[&quot;a&quot;] [&quot;b&quot; &quot;c&quot;] [&quot;e&quot; &quot;f&quot; &quot;g&quot;]]
   :doc &quot;This a sample example of a function to transform into a list of inputs.&quot;})</pre></td></tr><tr><td class="docs"><p>This is the success callback function which will be called when a
  request is successful. Accepts the name of the function and a map of response data.
  Sets the current state to <code>:fn-form-displaying</code> and adds the current map of metadata from the function
  fname</p>
</td><td class="codes"><pre class="brush: clojure">(defn- fn-display-callback
  [fname response]
    (swap! state-fnx (fn [old]
                     (assoc old
                       :state :fn-form-displaying
                       :current-fn (:meta-fn response)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod action-fnx :fn-clicked [{f :fn}]
  (remote :load-map-meta-fn {:fq-fn f} #(fn-display-callback f %)))</pre></td></tr><tr><td class="docs"><p>This is the success callback function which will be called when a
  request is successful. Accepts the name of the function, the args with
  which the fn will be called and a response data.
  Sets the current state to `:fn-result-showing'</p>
</td><td class="codes"><pre class="brush: clojure">(defn- fn-display-result-callback
  [fname args response]
    (swap! state-fnx (fn [old]
                     (assoc old
                       :state :fn-result-showing
                       :current-fn fname
                       :args args
                       :fn-result (:res response)))))</pre></td></tr><tr><td class="docs"><p>React to the run clicked event that will launch the execution of the function in the server</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod action-fnx :run-clicked [{f :fname args :args}]
  ;; before launching the computing of function in remote
  (swap! state-fnx  (fn [old]
                     (assoc old
                       :state :fn-running
                       :current-fn f
                       :args args)))

  ;; launch the function computing
  (remote :apply-fn {:meta-fn f
                     :args args} #(fn-display-result-callback f args %)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dispatch/react-to #{:init :ns-clicked :fn-clicked :run-clicked}
                   (fn [t d] (action-fnx (assoc d :type t))))</pre></td></tr><tr><td class="docs"><p>--------------- </fnx> ---------------</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.core" name="one.sample.core"><h1 class="project-name">one.sample.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Contains the entry point for the ClojureScript sample application.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.sample.core
  (:require [goog.uri.utils :as uri]
            [clojure.browser.repl :as repl]
            [one.dispatch :as dispatch]
            [one.sample.view :as view]))</pre></td></tr><tr><td class="docs"><p><strong>TODO:</strong> Add marginalia comment to explain what <code>:export</code> is for.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Return a string which is the scheme and domain portion of the URL
  for the server from which this code was served.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- server
  []
  (let [location (.toString window.location ())]
    (str (uri/getScheme location) &quot;://&quot; (uri/getDomain location))))</pre></td></tr><tr><td class="docs"><p>Connects to a ClojureScript REPL running on localhost port 9000.</p>

<p>  This allows a browser-connected REPL to send JavaScript to the
  browser for evaluation. This function should be called from a script
  in the development host HTML page.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:export repl
  []
  (repl/connect (str (server) &quot;:9000/repl&quot;)))</pre></td></tr><tr><td class="docs"><p>Start the application by firing a <code>:init</code> event which will cause the
  form view to be displayed.</p>

<p>  This function must be called from the host HTML page to start the
  application.</p>
</td><td class="codes"><pre class="brush: clojure">(defn ^:export start
  []
  (dispatch/fire :init))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.history" name="one.sample.history"><h1 class="project-name">one.sample.history</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>When this library is loaded, a listener function is added
  which will be run when a :form or :greeting event is fired. This
  allows the use of the back button to navigate between views. This is
  accomplished by using library.browser.history to keep track of views
  that have previously been visited, and traversing them when
  navigation events are detected.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.sample.history
  (:use [clojure.string :only [join]])
  (:require [one.dispatch :as dispatch]
            [one.browser.history :as history]))</pre></td></tr><tr><td class="docs"><p>Utilities functions to manipulate strings</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Given a string with keyword, remove the : character</p>
</td><td class="codes"><pre class="brush: clojure">(defn- rm-colon 
  [s]
  (join &quot;&quot; (replace {&quot;:&quot; &quot;&quot;} s)))</pre></td></tr><tr><td class="docs"><p>Split a string according to a sep (returns a seq).</p>
</td><td class="codes"><pre class="brush: clojure">(defn- split 
  [s sep]
  (seq (.split s sep)))</pre></td></tr><tr><td class="docs"><p>Utilities functions to manipulate extract token and map from the uri</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Given a string representing the rest of the uri, returns a map.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- attr-2-map 
  [s]
  (when s
    (let [v (split s &quot;&amp;&quot;)]
      (reduce (fn [m e]
                (let [[key val] (split e &quot;=&quot;)]
                  (assoc m (keyword key) val))) {} v))))</pre></td></tr><tr><td class="docs"><p>Given a token, returns a vector containing a token a map:
  - token represents the event to fire
  - the map represents the attributes key-value (key=value&amp;) contained in the url (after the ?)</p>
</td><td class="codes"><pre class="brush: clojure">(defn- token-2-map
  [token]
  (let [[t v] (split (rm-colon token) &quot;?&quot;)]
    [t (attr-2-map v)]))</pre></td></tr><tr><td class="docs"><p>Handle navigation events by firing the appropriate view token.</p>
</td><td class="codes"><pre class="brush: clojure">(defn nav-handler
  [{:keys [token navigation?]}]
  (let [[t m] (token-2-map token)]
    (when navigation?
      (dispatch/fire t m))))</pre></td></tr><tr><td class="docs"><p>The global history object for this application.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  history (history/history nav-handler))</pre></td></tr><tr><td class="docs"><p>Utilities function to update the nav bar according to the events triggered!</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Given a first degree (only one level) map, returns a uri</p>
</td><td class="codes"><pre class="brush: clojure">(defn- attr-2-uri 
  [e]
  (join &quot;&amp;&quot; (map (fn [k] (join &quot;=&quot; [k (e k)])) (keys e))))</pre></td></tr><tr><td class="docs"><p>Given a token and a map, returns a uri.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- map-2-uri 
  [t e]
  (if e (str t &quot;?&quot; (attr-2-uri e)) t))</pre></td></tr><tr><td class="docs"><p>Given a token event and a map, complete the uri nav bar.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- which-token 
  [t e]
  (cond (#{:init} t) :form
        (#{:ns-clicked} t) (map-2-uri t e)
        :else t))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dispatch/react-to
 #{:init :form :greeting :ns-clicked}
 (fn [t e]
   (history/set-token history (which-token t e))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.logging" name="one.sample.logging"><h1 class="project-name">one.sample.logging</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>When this library is loaded, create a logger named
'events' and send all application-specific events to it.</p>

<p>To view log messages in the browser console, add a call
to <code>(log/console-output)</code> to this namespace or evaluate this from the
REPL.</p>

<p>For more information see library.logging.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.sample.logging
  (:require [one.dispatch :as dispatch]
            [one.logging :as log]))</pre></td></tr><tr><td class="docs"><p>The logger that receives all application-specific events.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  logger (log/get-logger &quot;events&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dispatch/react-to (constantly true)
                   (fn [t d] (log/info logger (str (pr-str t) &quot; - &quot; (pr-str d)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  ;; log to to the &quot;fancy&quot; window
  (log/start-display (log/fancy-output &quot;main&quot;)))</pre></td></tr><tr><td class="docs"><p>log to the console</p>
</td><td class="codes"><pre class="brush: clojure">(log/start-display (log/console-output))</pre></td></tr><tr><td class="docs"><p>change the logging level</p>
</td><td class="codes"><pre class="brush: clojure">(log/set-level logger :fine)</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.model" name="one.sample.model"><h1 class="project-name">one.sample.model</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Contains client-side state, validators for input fields
 and functions which react to changes made to the input fields.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
 one.sample.model
  (:require [one.dispatch :as dispatch]))</pre></td></tr><tr><td class="docs"><p>An atom containing a map which is the application's current state.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  state (atom {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-watch state :state-change-key
           (fn [k r o n]
             (dispatch/fire :state-change n)))</pre></td></tr><tr><td class="docs"><p>------------- fnx ------------- </p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>An atom containing a map which is the application's current state.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  state-fnx (atom {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-watch state-fnx :state-change-key
           (fn [k r o n]
             (dispatch/fire :state-change-fnx n)))</pre></td></tr><tr><td class="docs"><p>------------- fnx ------------- </p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>An atom containing the state of the greeting form and
  each of its fields.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true
       :doc }
  greeting-form (atom {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(add-watch greeting-form :form-change-key
           (fn [k r o n]
             (dispatch/fire :form-change {:old o :new n})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti ^:private new-status
  (fn [&amp; args] (vec args)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def error-status
  {:status :error
   :error &quot;Are you sure about that? Names must have at least two characters.&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def editing-error-status
  {:status :editing-error
   :error &quot;Names must have at least two characters.&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:empty :focus :empty] [p e f]
  {:status :editing})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing :finished :empty] [p e f]
  {:status :empty})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing :change :empty] [p e f]
  {:status :editing})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing :change :error] [p e f]
  {:status :editing})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing :change :valid] [p e f]
  {:status :editing-valid})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing :finished :error] [p e f]
  error-status)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing-valid :change :error] [p e f]
  {:status :editing})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing-valid :change :valid] [p e f]
  {:status :editing-valid})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing-valid :finished :valid] [p e f]
  {:status :valid})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:error :focus :error] [p e f]
  editing-error-status)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing-error :change :error] [p e f]
  editing-error-status)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing-error :finished :error] [p e f]
  error-status)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing-error :change :valid] [p e f]
  {:status :editing-valid})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing-error :change :empty] [p e f]
  {:status :editing-error})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:editing-error :finished :empty] [p e f]
  {:status :empty})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:valid :focus :valid] [p e f]
  {:status :editing-valid})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status [:valid :finished :empty] [p e f]
  {:status :empty})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod new-status :default [p e f]
  {:status p})</pre></td></tr><tr><td class="docs"><p>Accepts a form id and a value and returns a map
  with <code>:value</code>, <code>:status</code>, and <code>:error</code> keys. Status will be set to
  either <code>:valid</code> or <code>:error</code>. If there was an error, then there will be
  an error message associated with the <code>:error</code> key.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti ^:private validate
  (fn [id _] id))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod validate &quot;name-input&quot; [_ v]
  (cond (= (count v) 0) :empty
        (= (count v) 1) :error
        :else :valid))</pre></td></tr><tr><td class="docs"><p>Calculates the status of the whole form based on the status of each
  field. Retuns <code>:finished</code> or <code>:editing</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- form-status
  [m]
  (if (every? #(or (= % :valid) (= % :editing-valid)) (map :status (vals (:fields m))))
    :finished
    :editing))</pre></td></tr><tr><td class="docs"><p>Accepts a field-id and value. Validates the field and updates the
  greeting form atom.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- set-field-value
  [field-id type value]
  (swap! greeting-form
         (fn [old]
           (let [field (get (:fields old) field-id {})
                 field-status (assoc (new-status (-&gt; old :fields field-id :status)
                                                 type
                                                 (validate field-id value))
                                :value value)
                 new (assoc-in old [:fields field-id] field-status)]
             (assoc new :status (form-status new))))))</pre></td></tr><tr><td class="docs"><p>Update the form state for a given field to indicate that the form
  is still being edited.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- set-editing
  [id]
  (swap! greeting-form
         (fn [old]
           (let [field-map (-&gt; old :fields id)
                 status (or (:status field-map) :empty)
                 field-status (new-status status
                                          :focus
                                          status)]
             (-&gt; old
                 (assoc-in [:fields id] (assoc field-status :value (:value field-map)))
                 (assoc :status (form-status old)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dispatch/react-to (fn [e] (= (first e) :field-finished))
                   (fn [[_ id] value]
                     (set-field-value id :finished value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dispatch/react-to (fn [e] (= (first e) :field-changed))
                   (fn [[_ id] value]
                     (set-field-value id :change value)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dispatch/react-to (fn [e] (= (first e) :editing-field))
                   (fn [[_ id] _]
                     (set-editing id)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dispatch/react-to #{:form-submit}
  (fn [t d]
    (let [form-data @greeting-form]
      (when (= (:status form-data) :finished)
        (dispatch/fire :greeting {:name (-&gt; form-data :fields &quot;name-input&quot; :value)})))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.view" name="one.sample.view"><h1 class="project-name">one.sample.view</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Render the views for the application.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.sample.view
  (:use [domina :only (set-html! append! set-styles! styles by-id set-style!
                                 by-class value set-value! set-text! nodes single-node destroy-children!)]
        [domina.xpath :only (xpath)]
        [one.browser.animation :only (play)]
        [one.sample.view-helper :only [ls-curr-ns parent-ns]])
  (:require-macros [one.sample.snippets :as snippets])
  (:require [goog.events.KeyCodes :as key-codes]
            [goog.events.KeyHandler :as key-handler]
            [clojure.browser.event :as event]
            [one.dispatch :as dispatch]
            [one.sample.animation :as fx]))</pre></td></tr><tr><td class="docs"><p>A map which contains chunks of HTML which may be used
  when rendering views.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  snippets (snippets/snippets))</pre></td></tr><tr><td class="docs"><p>Render the submit button based on the current state of the
  form. The button is disabled while the user is editing the form and
  becomes enabled when the form is complete.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti render-button
  identity)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-button :default [_])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-button [:finished :editing] [_]
  (fx/disable-button &quot;greet-button&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-button [:editing :finished] [_]
  (fx/enable-button &quot;greet-button&quot;))</pre></td></tr><tr><td class="docs"><p>Render a form field based on the current state transition. Form
  fields are validated as soon as they lose focus. There are six
  transitions and each one has its own animation.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti render-form-field
  :transition)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-form-field :default [_])</pre></td></tr><tr><td class="docs"><p>Accepts an element id for an input field and return the xpath
  string to the label for that field.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- label-xpath
  [id]
  (str &quot;//label[@id='&quot; id &quot;-label']/span&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-form-field [:empty :editing] [{:keys [id]}]
  (fx/label-move-up (label-xpath id)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-form-field [:editing :empty] [{:keys [id]}]
  (fx/label-move-down (label-xpath id)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-form-field [:editing-valid :valid] [{:keys [id]}]
  (fx/label-fade-out (label-xpath id)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-form-field [:valid :editing-valid] [{:keys [id]}]
  (play (label-xpath id) fx/fade-in))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-form-field [:editing :error] [{:keys [id error]}]
  (let [error-element (by-id (str id &quot;-error&quot;))]
    (set-style! error-element &quot;opacity&quot; &quot;0&quot;)
    (set-html! error-element error)
    (play error-element fx/fade-in)))</pre></td></tr><tr><td class="docs"><p>Accepts an id and an error message and fades the old error message
  out and the new one in.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- swap-error-messages
  [id error]
  (let [error-element (by-id (str id &quot;-error&quot;))]
    (play error-element fx/fade-out
             {:name &quot;fade out error&quot;})
    (play error-element fx/fade-in {:before #(set-html! error-element error)})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-form-field [:error :editing-error] [{:keys [id error]}]
  (swap-error-messages id error))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-form-field [:editing-error :error] [{:keys [id error]}]
  (swap-error-messages id error))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-form-field [:editing-error :editing-valid] [{:keys [id]}]
  (let [error-element (by-id (str id &quot;-error&quot;))]
    (play error-element (assoc fx/fade-out :time 200))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-form-field [:editing-error :empty] [{:keys [id]}]
  (let [error-element (by-id (str id &quot;-error&quot;))]
    (play error-element (assoc fx/fade-out :time 200))
    (fx/label-move-down (label-xpath id))))</pre></td></tr><tr><td class="docs"><p>Accepts a field-id and creates listeners for blur and focus events which will then fire
  <code>:field-changed</code> and <code>:editing-field</code> events.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- add-input-event-listeners
  [field-id]
  (let [field (by-id field-id)
        keyboard (goog.events.KeyHandler. (by-id &quot;form&quot;))]
    (event/listen field
                  &quot;blur&quot;
                  #(dispatch/fire [:field-finished field-id] (value field)))
    (event/listen field
                  &quot;focus&quot;
                  #(dispatch/fire [:editing-field field-id]))
    (event/listen field
                  &quot;keyup&quot;
                  #(dispatch/fire [:field-changed field-id] (value field)))
    (event/listen keyboard
                  &quot;key&quot;
                  (fn [e] (when (= (.-keyCode e) key-codes/ENTER)
                           (do (.blur (by-id &quot;name-input&quot;) ())
                               (dispatch/fire :form-submit)))))))</pre></td></tr><tr><td class="docs"><p>Accepts a map which represents the current state of the application
  and renders a view based on the value of the <code>:state</code> key.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti render
  :state)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render :init [_]
  (comment
    (fx/initialize-views (:form snippets) (:greeting snippets))
    (add-input-event-listeners &quot;name-input&quot;)
    (event/listen (by-id &quot;greet-button&quot;)
                  &quot;click&quot;
                  #(dispatch/fire :greeting
                                  {:name (value (by-id &quot;name-input&quot;))}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render :form [{:keys [state error name]}]
  (fx/show-form)
  (set-value! (by-id &quot;name-input&quot;) &quot;&quot;)
  (dispatch/fire [:field-finished &quot;name-input&quot;] &quot;&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render :greeting [{:keys [state name exists]}]
  (set-text! (single-node (by-class &quot;name&quot;)) name)
  (set-text! (single-node (by-class &quot;again&quot;)) (if exists &quot;again&quot; &quot;&quot;))
  (fx/show-greeting))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dispatch/react-to #{:state-change} (fn [_ m] (render m)))</pre></td></tr><tr><td class="docs"><p>------------- fnx ------------- </p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Accepts a map which represents the current state of the application
  and renders a view based on the value of the <code>:state</code> key.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti render-fnx
  :state)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-fnx :init [_]
  (fx/initialize-views-fnx
   (:ns-nav snippets)
   (:fn-display snippets)
   (:spinner snippets)
   (:prev snippets)))</pre></td></tr><tr><td class="docs"><p>Hide the element with id id</p>
</td><td class="codes"><pre class="brush: clojure">(defn- hide 
  [id]
  (set-styles! (by-id id) {:display &quot;none&quot;}))</pre></td></tr><tr><td class="docs"><p>Show the element with id id</p>
</td><td class="codes"><pre class="brush: clojure">(defn- show 
  [id]
  (set-styles! (by-id id) {:display &quot;block&quot;}))</pre></td></tr><tr><td class="docs"><p>Display or not the prev block depending on the current namespace.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- previous-ns-block 
  [all-ns ns-nav]
  ;; Deal with ..
  (let [prev (by-id &quot;prev&quot;)]
    (if ns-nav
      (do
        (set-styles! prev {:display &quot;block&quot;})
        (event/listen prev &quot;click&quot;
                      #(dispatch/fire :ns-clicked {:ns (parent-ns all-ns ns-nav)})))
      (set-styles! prev {:display &quot;none&quot;}))))</pre></td></tr><tr><td class="docs"><p>Display namespaces</p>
</td><td class="codes"><pre class="brush: clojure">(defn- display-lns 
  [lns]
  (let [nsn (by-id &quot;ns-nav&quot;)]
    (when lns
      ;; show the namespace block
      (set-styles! nsn {:display &quot;block&quot; :color &quot;red&quot;})
      ;; destroy the content on this block
      (destroy-children! nsn)
      ;; display the list of namespaces
      (dorun (map #(append! nsn (str &quot;&lt;div id='ns-&quot; % &quot;'&gt;&quot;  % &quot;&lt;/div&gt;&quot;)) lns))
      ;; event when click on one of the ns
      (dorun (map (fn [n] (event/listen
                           (by-id (str &quot;ns-&quot; n))
                           &quot;click&quot;
                           #(dispatch/fire :ns-clicked {:ns n}))) lns)))))</pre></td></tr><tr><td class="docs"><p>Display functions list</p>
</td><td class="codes"><pre class="brush: clojure">(defn- display-fns 
  [fns]
  (let [fnd (by-id &quot;fn-display&quot;)]
    (when fns
      ;; show the function block
      (set-styles! fnd {:display &quot;block&quot; :color &quot;blue&quot;})
      ;; destroy the content on this block
      (destroy-children! fnd)
      ;; display the list of functions
      (dorun (map #(append! fnd (str &quot;&lt;div id='fn-&quot; % &quot;'&gt;&quot;  % &quot;&lt;/div&gt;&quot;)) fns))
      ;; event when click on one of the fn
      (dorun (map (fn [f] (event/listen
                           (by-id (str &quot;fn-&quot; f))
                           &quot;click&quot;
                           #(dispatch/fire :fn-clicked {:fn f}))) fns)))))</pre></td></tr><tr><td class="docs"><p>Reset the content of a div with id id</p>
</td><td class="codes"><pre class="brush: clojure">(defn- reset-ids 
  [&amp; ids]
  (dorun (map #(destroy-children! (by-id %)) ids)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-fnx :ns-navigating [{:keys [all-ns ns-nav]}]
  (let [lns-fns (ls-curr-ns all-ns ns-nav)]
    ;; reset or hide things part
    (hide &quot;spinner&quot;)
    (reset-ids &quot;ns-nav&quot; &quot;fn-display&quot;)

    ;; display part
    (previous-ns-block all-ns ns-nav)
    (display-lns (first lns-fns))
    (display-fns (second lns-fns))))</pre></td></tr><tr><td class="docs"><p>Compute the name of a function coupled with its arity</p>
</td><td class="codes"><pre class="brush: clojure">(defn- fn-ar 
  [fname arity]
  (str fname &quot;-&quot; arity))</pre></td></tr><tr><td class="docs"><p>Display the args of a function into a list of inputs</p>
</td><td class="codes"><pre class="brush: clojure">(defn- display-args 
  [fnd {:keys [fname] :as f} args]
  (let [arity (count args)
        fnar (fn-ar fname arity)
        button-id (str &quot;run-button-&quot; fnar)]
    ;; display the inputs
    (append! fnd (str &quot;&lt;h3&gt;Input the arguments - Arity - &quot; arity &quot;&lt;/h3&gt;&quot;))
    ;; find a way to use the templating...
    (dorun (map #(append! fnd (let [n (str fnar &quot;-&quot; (str %))]
                                (str
                                 &quot;&lt;div class='input'&gt;&quot;
                                 &quot;&lt;label id='label-&quot; n &quot;'&gt;&quot;
                                 &quot;&lt;span&gt;&quot; (str %) &quot;&lt;/span&gt;&quot;
                                 &quot;&lt;input id='id-fn-&quot; n &quot;' size='30' type= 'text'/&gt;&quot;
                                 &quot;&lt;/label&gt;&quot;
                                 &quot; &lt;div id='id-input-error-&quot; n &quot;' class='small error'&gt;&amp;nbsp;&lt;/div&gt;&quot;
                                 &quot;&lt;/div&gt;&quot;)))
                args))
    ;; display the button run
    (append! fnd (str &quot;&lt;div class='input'&gt;&lt;input type='button' id='&quot; button-id
                      &quot;' value='run!' /&gt;&lt;/div&gt;&quot;))
    ;; add a listener to it
    (event/listen (by-id button-id)
                  &quot;click&quot;
                  #(dispatch/fire :run-clicked
                                  {:fname f
                                   :args (reduce (fn [m i]
                                                   (assoc m i (value (by-id
                                                                      (str &quot;id-fn-&quot; fnar &quot;-&quot; (str i))))))
                                                 {} args)}))))</pre></td></tr><tr><td class="docs"><p>Display the function</p>
</td><td class="codes"><pre class="brush: clojure">(defn- display-fn 
  [{:keys [fname arglists doc] :as f}]
  (let [fnd (by-id &quot;fn-display&quot;)]
    (when f
      ;; show the function block
      (set-styles! fnd {:display &quot;block&quot; :color &quot;blue&quot;})
      ;; destroy the content on this block
      (destroy-children! fnd)
      (append! fnd (by-id &quot;spinner&quot;))
      (hide &quot;spinner&quot;)
      (append! fnd (str &quot;&lt;h2 id='fn-&quot; fname &quot;'&gt;&quot; fname &quot;&lt;/h2&gt;&quot;))
      (append! fnd (str &quot;&lt;div&gt;&quot; (when doc doc) &quot;&lt;/div&gt;&quot;))
      ;; beware at the multiple arities
      (dorun (map #(display-args fnd f %) arglists)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-fnx :fn-form-displaying [{:keys [all-ns ns-nav current-fn]}]
  (let [lns-fns (ls-curr-ns all-ns ns-nav)]
    (reset-ids &quot;ns-nav&quot; &quot;fn-display&quot;)

    ;; display part
    (previous-ns-block all-ns ns-nav)
    (display-fn current-fn)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-fnx :fn-running [{:keys [current-fn args]}]
  (show &quot;spinner&quot;)
  (set-styles! (by-id &quot;fn-display&quot;) {:opacity &quot;0.5&quot;}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod render-fnx :fn-result-showing [{:keys [current-fn args fn-result]}]
  (let [fnd (by-id &quot;fn-display&quot;)
        fname (current-fn :fname)]

    (hide &quot;spinner&quot;)
    (set-styles! (by-id &quot;fn-display&quot;) {:opacity &quot;1&quot;})

    (when fname

      ;; display the list of functions
      (append! fnd (str &quot;&lt;div id='fn-result'&gt;&quot; fname &quot; - &quot; (pr-str args) &quot; - &quot; (pr-str fn-result) &quot;&lt;/div&gt;&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dispatch/react-to #{:state-change-fnx} (fn [_ m] (render-fnx m)))</pre></td></tr><tr><td class="docs"><p>------------- fnx -------------</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Given a map of old and new form states, generate a map with <code>:id</code>,
  <code>:transition</code> and <code>:error</code> keys which can be passed to
  <code>render-form-field</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- form-fields-status
  [m]
  (map #(hash-map :id %
                  :transition [(or (-&gt; m :old :fields % :status) :empty)
                               (-&gt; m :new :fields % :status)]
                  :error (-&gt; m :new :fields % :error))
       (keys (-&gt; m :new :fields))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dispatch/react-to #{:form-change}
                   (fn [_ m]
                     (doseq [s (form-fields-status m)]
                       (render-form-field s))
                     (render-button [(-&gt; m :old :status)
                                     (-&gt; m :new :status)] )))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.sample.view-helper" name="one.sample.view-helper"><h1 class="project-name">one.sample.view-helper</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns one.sample.view-helper)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ls-curr-ns
  [all-ns curr-ns] (let [[_ nses fns] (all-ns curr-ns)]
                     [nses fns]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parent-ns
  [all-ns curr-ns] (first (all-ns curr-ns)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.browser.animation" name="one.browser.animation"><h1 class="project-name">one.browser.animation</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provides support for basic animations. Allows effects to be
  represented as Clojure data.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.browser.animation
  (:use [one.color :only (color bg-color rgb IColorSource)]
        [one.core :only (start dispose get-style)])
  (:require [goog.style :as style]
            [goog.string :as gstring]
            [goog.fx.AnimationQueue :as queue]
            [goog.fx.easing :as easing]
            [goog.fx.dom :as anim]
            [goog.async.Delay :as delay]
            [clojure.browser.event :as event]
            [clojure.browser.dom :as dom]
            [domina :as d]
            [domina.xpath :as dx]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:dynamic *default-time* 1000)</pre></td></tr><tr><td class="docs"><p>Accepts a keyword, string or element and returns an
  element. Strings are assumed to be xpath format.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- get-element
  [e]
  (cond (keyword? e) (d/by-id (name e))
        (string? e) (first (d/nodes (dx/xpath e)))
        :else e))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IPosition
  (position [this] &quot;Return the position of the passed object as a 2D array, `[X Y]`.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol IPosition

  cljs.core.Vector
  (position [this] this)

  js/Array
  (position [this] (js-&gt;clj this))

  js/Element
  (position [this]
    (let [p (js-&gt;clj (style/getPosition this) :keywordize-keys true)]
      [(:x p) (:y p)])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IScroll
  (scroll [this] &quot;Return the scroll position of an element as `[X Y]`.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol IScroll

  js/Number
  (scroll [this] [0 this])

  cljs.core.Vector
  (scroll [this] this)

  js/Element
  (scroll [this]
    [(.-scrollLeft this) (.-scrollTop this)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ISize
  (size [this] &quot;Return the size of an element as `[W H]`.&quot;)
  (width [this] &quot;Return the width of an element.&quot;)
  (height [this] &quot;Return the height of an element.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol ISize

  js/Number
  (size [this] [this this])
  (width [this] this)
  (height [this] this)

  cljs.core.Vector
  (size [this] this)
  (width [this] (first this))
  (height [this] (second this))

  js/Element
  (size [this]
    (let [s (js-&gt;clj (style/getSize this)
                     :keywordize-keys true)]
      [(:width s) (:height s)]))
  (width [this]
    (width (size this)))
  (height [this]
    (height (size this))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IOpacity
  (opacity [this] &quot;Return the elements current opacity.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol IOpacity

  js/String
  (opacity [this]
    (js/parseFloat this))

  js/Number
  (opacity [this] this)

  js/Element
  (opacity [this]
    (let [op (style/getComputedStyle this &quot;opacity&quot;)]
      (if (= op &quot;&quot;)
        (opacity (style/getOpacity this))
        op))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type goog.fx.AnimationQueue
  
  one.core/Startable
  (start [this] (.play this ()))
  
  one.core/Disposable
  (dispose [this] (.dispose this ())))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type goog.fx.dom.PredefinedEffect
  
  one.core/Startable
  (start [this] (.play this ()))
  
  one.core/Disposable
  (dispose [this] (.dispose this ()))
  
  event/EventType
  (event-types [this]
    (into {}
          (map
           (fn [[k v]]
             [(keyword (. k (toLowerCase)))
              v])
           (merge (js-&gt;clj goog.fx.Animation.EventType))))))</pre></td></tr><tr><td class="docs"><p>Get the acceleration function associated with a given
  keyword. Implementing this as a multimethod allows developers to add new
  functions and still represent effects as data.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti acceleration
  identity :default :ease-out)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod acceleration :ease-out [name]
  easing/easeOut)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod acceleration :ease-in [name]
  easing/easeIn)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod acceleration :in-and-out [name]
  easing/inAndOut)</pre></td></tr><tr><td class="docs"><p>Given a map which represents an effect. Return the acceleration
  function or <code>nil</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- accel
  [m]
  (when-let [a (:accel m)]
    (if (fn? a)
      a
      (acceleration a))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Effect [effect start end time accel]
  one.color.IColorSource
  (color [this] (:end this))
  (bg-color [this] (:end this))
  IOpacity
  (opacity [this] (:end this))
  IPosition
  (position [this] (:end this))
  ISize
  (size [this] (:end this))
  (width [this] (width (:end this)))
  (height [this] (height (:end this)))
  IScroll
  (scroll [this] (:end this)))</pre></td></tr><tr><td class="docs"><p>Dispatch function for effect multimethods. Accepts an element and a
  map describing an effect and returns the effect name as a keyword.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- effect-dispatch
  [_ {effect :effect}] effect)</pre></td></tr><tr><td class="docs"><p>Accepts an element and an effect map and returns a standardized
  effect map which must contain the four keys: <code>:start</code>, <code>:end</code>,
  <code>:time</code> and <code>:accel</code>.</p>

<p>  The element argument can either be an HTML element or an effect map
  which describes the previous effect.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti standardize
  effect-dispatch)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :color [element m]
  (Effect. :color
           (color (or (:start m) element))
           (color (or (:end m) element))
           (or (:time m) *default-time*)
           (accel m)))</pre></td></tr><tr><td class="docs"><p>Accepts an element and a map and returns an effect. The returned
  effect may be run or composed with other effects.</p>

<p>  Available effects include: <code>:color</code>, <code>:fade</code>, <code>:fade-in</code>, <code>:fade-out</code>,
  <code>:fade-in-and-show</code>, <code>:fade-out-and-hide</code>, <code>:slide</code>, <code>:swipe</code>, <code>:bg-color</code>,
  <code>:resize</code>, <code>:resize-width</code> and <code>:resize-height</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti effect
  effect-dispatch)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :color [element m]
  (let [{:keys [start end time accel]} (standardize element m)]
    (goog.fx.dom.ColorTransform. element
                                 (apply array (rgb start))
                                 (apply array (rgb end))
                                 time
                                 accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Color effect examples
  (def label (get-element &quot;//label[@id='name-input-label']/span&quot;))
  (def label-color (color label))
  (def red [255 0 0])
  (def green [0 255 0])
  (start (effect label {:effect :color :end red}))
  (start (effect label {:effect :color :end green}))
  (start (effect label {:effect :color :end label-color}))
  (start (bind label
               {:effect :color :end red}
               {:effect :color :end green}
               {:effect :color :end label-color})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :fade [element m]
  (Effect. :fade
           (opacity (or (:start m) element))
           (opacity (:end m))
           (or (:time m) *default-time*)
           (accel m)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :fade [element m]
  (let [{:keys [start end time accel]} (standardize element m)]
    (goog.fx.dom.Fade. element start end time accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :fade-in [element m]
  (Effect. :fade-in 0 1 (or (:time m) *default-time*) (accel m)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :fade-in [element m]
  (let [{:keys [time accel]} (standardize element m)]
    (goog.fx.dom.FadeIn. element time accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :fade-out [element m]
  (Effect. :fade-out 1 0 (or (:time m) *default-time*) (accel m)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :fade-out [element m]
  (let [{:keys [time accel]} (standardize element m)]
    (goog.fx.dom.FadeOut. element time accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :fade-in-and-show [element m]
  (Effect. :fade-in-and-show 0 1 (or (:time m) *default-time*) (accel m)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :fade-in-and-show [element m]
  (let [{:keys [time accel]} (standardize element m)]
    (goog.fx.dom.FadeInAndShow. element time accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :fade-out-and-hide [element m]
  (Effect. :fade-out-and-hide 1 0 (or (:time m) *default-time*) (accel m)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :fade-out-and-hide [element m]
  (let [{:keys [time accel]} (standardize element m)]
    (goog.fx.dom.FadeOutAndHide. element time accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Fade effect examples
  (def label (get-element &quot;//label[@id='name-input-label']/span&quot;))
  (def title (get-element &quot;//div[@id='form']/h1&quot;))
  (def title-opacity (opacity title))
  (def label-opacity (opacity label))
  (start (effect label {:effect :fade :end 0.2}))
  (start (effect title {:effect :fade :end label}))
  (start (effect label {:effect :fade :end label-opacity}))
  (start (effect title {:effect :fade :end title-opacity}))
  (start (effect label {:effect :fade-out}))
  (start (effect label {:effect :fade-in}))
  (start (effect label {:effect :fade-out-and-hide}))
  (start (effect label {:effect :fade-in-and-show}))
  (start (bind label
               {:effect :fade :end 0 :time 2000}
               {:effect :fade :end 1 :time 2000}))
  ;; mix fade effects - cannot mix both fade-in-and-show and
  ;; fade-out-and-hide in the same animation.
  (start (apply bind label
                (map #(assoc % :time 2000)
                     [{:effect :fade-out}
                      {:effect :fade :end 1}
                      {:effect :fade :end 0}
                      {:effect :fade-in}
                      {:effect :fade :end 0}
                      {:effect :fade :end 1}]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :bg-color [element m]
  (let [start (or (:start m) element)
        end (or (:end m) element)]
    (Effect. :bg-color
             (bg-color start)
             (bg-color end)
             (or (:time m) *default-time*)
             (accel m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :bg-color [element m]
  (let [{:keys [start end time accel]} (standardize element m)]
    (goog.fx.dom.BgColorTransform. element
                                   (apply array (rgb start))
                                   (apply array (rgb end))
                                   time
                                   accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Background color effect examples
  (def input (get-element :name-input))
  (def red [255 0 0])
  (def green [0 255 0])
  (def input-bg-color (bg-color input))
  (def input-color (color input))
  (start (effect input {:effect :bg-color :end red}))
  (start (effect input {:effect :bg-color :end green}))
  (start (effect input {:effect :bg-color :end input-bg-color}))
  (start (bind input
               {:effect :bg-color :end red}
               {:effect :bg-color :end green}
               {:effect :bg-color :end input-bg-color})))</pre></td></tr><tr><td class="docs"><p>Calculate the end of a slide based on the start value and the
  passed <code>:left</code>, <code>:right</code>, <code>:up</code> and <code>:down</code> values.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- calculate-slide-end
  [[x y] m]
  (vector (+ (- x (:left m 0)) (:right m 0))
          (+ (- y (:up m 0)) (:down m 0))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :slide [element m]
  (let [start (position (or (:start m) element))
        end (or (:end m) (calculate-slide-end start m))]
    (Effect. :slide
             start
             end
             (or (:time m) *default-time*)
             (accel m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :slide [element m]
  (let [{:keys [start end time accel]} (standardize element m)]
    (goog.fx.dom.Slide. element
                        (apply array start)
                        (apply array end)
                        time
                        accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Slide effect examples
  (def label (get-element &quot;//label[@id='name-input-label']/span&quot;))
  (start (effect label {:effect :slide :up 40 :time 100}))
  (start (effect label {:effect :slide :down 40 :time 100}))
  ;; Easing examples
  (start (effect label {:effect :slide :up 200 :accel :ease-out}))
  (start (effect label {:effect :slide :down 200 :accel :ease-in}))
  ;; slide up and then down
  (start (bind label
               {:effect :slide :up 200 :time 2000 :accel :ease-out}
               {:effect :slide :down 200 :time 2000 :accel :ease-in})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :resize-height [element m]
  (let [start (when-let [h (:start m)] [(width element) (height h)])
        end (when-let [h (:end m)] [(width element) (height h)])]
    (Effect. :resize-height
            (size (or start element))
            (size (or end element))
            (or (:time m) *default-time*)
            (accel m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :resize-height [element m]
  (let [{:keys [start end time accel]} (standardize element m)]
    (goog.fx.dom.ResizeHeight. element (height start) (height end) time accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :resize-width [element m]
  (let [start (when-let [w (:start m)] [(width w) (height element)])
        end (when-let [w (:end m)] [(width w) (height element)])]
    (Effect. :resize-width
            (size (or start element))
            (size (or end element))
            (or (:time m) *default-time*)
            (accel m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :resize-width [element m]
  (let [{:keys [start end time accel]} (standardize element m)]
    (goog.fx.dom.ResizeWidth. element (width start) (width end) time accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :resize [element m]
  (Effect. :resize
           (size (or (:start m) element))
           (size (or (:end m) element))
           (or (:time m) *default-time*)
           (accel m)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :resize [element m]
  (let [{:keys [start end time accel]} (standardize element m)]
    (goog.fx.dom.Resize. element
                         (apply array start)
                         (apply array end)
                         time
                         accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Resize examples
  (def button (get-element :greet-button))
  (def button-size (size button))
  (def button-height (height button))
  (def button-width (width button))
  (start (effect button {:effect :resize :end [200 200]}))
  (start (effect button {:effect :resize :end button-size}))
  (start (effect button {:effect :resize-height :end 200}))
  (start (effect button {:effect :resize-height :end button-height}))
  (start (effect button {:effect :resize-width :end 200}))
  (start (effect button {:effect :resize-width :end button-width}))
  (start (bind button
               {:effect :resize :end [200 200]}
               {:effect :resize-height :end 300}
               {:effect :resize-width :end 300}
               {:effect :resize-height :end 200}
               {:effect :resize-width :end 200}
               {:effect :resize :end button-size})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :scroll [element m]
  (let [start (or (:start m) element)
        end (:end m)]
    (Effect. :scroll
             (scroll start)
             (scroll end)
             (or (:time m) *default-time*)
             (accel m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :scroll [element m]
  (let [{:keys [start end time accel]} (standardize element m)]
    (goog.fx.dom.Scroll. element
                         (apply array start)
                         (apply array end)
                         time
                         accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Scroll examples
  (def doc (get-element &quot;//body&quot;))
  ;; Make the window small before trying this.
  (start (effect doc {:effect :scroll :end [500 500]}))
  (start (effect doc {:effect :scroll :end [0 0]}))
  (start (effect doc {:effect :scroll :end 300}))
  (start (effect doc {:effect :scroll :end 0}))
  (start (bind doc
               {:effect :scroll :end [500 500]}
               {:effect :scroll :end [0 0]}
               {:effect :scroll :end 300}
               {:effect :scroll :end 0})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod standardize :swipe [element m]
  (let [start (or (:start m) [0 0])
        end (or (:end m) element)]
    (Effect. :swipe
             (size start)
             (size end)
             (or (:time m) *default-time*)
             (accel m))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod effect :swipe [element m]
  (let [{:keys [start end time accel]} (standardize element m)]
    (goog.fx.dom.Swipe. element
                        (apply array start)
                        (apply array end)
                        time
                        accel)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Swipe examples
  (def button (get-element :greet-button))
  (def button-size (size button))
  (style/setStyle button &quot;position&quot; &quot;absolute&quot;)
  (start (effect button {:effect :swipe :start [100 0] :time 300}))
  (start (effect button {:effect :swipe :start [0 45] :time 300}))
  (start (effect button {:effect :swipe :time 300}))
  (style/setStyle button &quot;position&quot; ))</pre></td></tr><tr><td class="docs"><p>Cause the passed animations to run in parallel.</p>
</td><td class="codes"><pre class="brush: clojure">(defn parallel
  [&amp; effects]
  (let [parallel (goog.fx.AnimationParallelQueue.)]
    (doseq [effect effects] (.add parallel effect))
    parallel))</pre></td></tr><tr><td class="docs"><p>Cause the passed animations to be run in order.</p>
</td><td class="codes"><pre class="brush: clojure">(defn serial
  [&amp; effects]
  (let [serial (goog.fx.AnimationSerialQueue.)]
    (doseq [effect effects]
      (.add serial effect))
    serial))</pre></td></tr><tr><td class="docs"><p>Mapping of specific effects to a more general category of
  effect. For example, there are multiple size and opacity
  effects. Within a single animation, each type of effect should
  influence subsequent effects of the same type.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:doc 
       :private true}
  effect-types
  {:color             :color
   :fade              :opacity
   :fade-in           :opacity
   :fade-out          :opacity
   :fade-in-and-show  :opacity
   :fade-out-and-hide :opacity
   :bg-color          :bg-color
   :slide             :position
   :resize            :size
   :resize-height     :size
   :resize-width      :size
   :scroll            :scroll
   :swipe             :size})</pre></td></tr><tr><td class="docs"><p>Standardize an effect within the scope of previous effects. Return
  a vector containing the new environment and the standardized
  effect. An effect may be a single map or a vector of maps</p>
</td><td class="codes"><pre class="brush: clojure">(defn- standardize-in-env
  [element env effect]
  (if (vector? effect)
    (let [coll (map #(standardize-in-env element env %) effect)]
      [(apply merge (map first coll)) (vec (map second coll))])
    (let [effect-type ((:effect effect) effect-types)
          effect (standardize (get env effect-type element) effect)
          env (assoc env effect-type effect)]
      [env effect])))</pre></td></tr><tr><td class="docs"><p>Accepts an element and a list of effects and vectors of effects and
  returns the same structure with all effect map standardized. Missing
  values will be calculated based on previous effects.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- standardize-all-effects
  [element &amp; effects]
  (loop [env {}
         effects effects
         std-effects []]
    (if (seq effects)
      (let [effect (first effects)
            [env effect] (standardize-in-env element env effect)]
        (recur env
               (rest effects)
               (conj std-effects effect)))
      std-effects)))</pre></td></tr><tr><td class="docs"><p>Bind effects to an element returning an animation. Accepts an HTML
  element and any number of effects. Effects can be Maps or a Vector
  of Maps. Each effect is run in order. Each effect within a Vector is
  run in parallel.</p>
</td><td class="codes"><pre class="brush: clojure">(defn bind
  [element &amp; effects]
  (let [element (get-element element)
        effects (apply standardize-all-effects element effects)
        serial (goog.fx.AnimationSerialQueue.)]
    (doseq [sequential-effect effects]
      (if (vector? sequential-effect)
        (let [parallel (goog.fx.AnimationParallelQueue.)]
          (doseq [parallel-effect sequential-effect]
            (.add parallel (effect element parallel-effect)))
          (.add serial parallel))
        (.add serial (effect element sequential-effect))))
    serial))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Bind examples
  (def label-color (color (get-element &quot;//label[@id='name-input-label']/span&quot;)))
  (def label (get-element &quot;//label[@id='name-input-label']/span&quot;))
  (def input (get-element :name-input))
  (def red [255 0 0])
  (def green [0 255 0])
  (def blue [0 0 255])
  (def input-bg-color (bg-color input))
  (def input-color (color input))
  (def button (get-element :greet-button))
  (def button-size (size button))
  (def move-label (bind label
                        [{:effect :slide :up 200 :time 2000}
                         {:effect :color :end red :time 2000}]
                        [{:effect :slide :down 200 :time 2000}
                         {:effect :color :end label-color :time 2000}]))
  (start move-label)
  (def background (bind input
                        {:effect :bg-color :end red}
                        {:effect :bg-color :end green}
                        {:effect :bg-color :end blue}
                        {:effect :bg-color :end input-bg-color}))
  (start background)
  ;; Serial and parallel animations on different elements
  (def big-button (bind button
                        {:effect :resize :end [200 200] :time 2000}
                        {:effect :resize :end button-size :time 2000}))
  (start big-button)
  (start (serial move-label background big-button))
  (start (parallel move-label background big-button)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Events
  ;; You may listen for &quot;begin&quot; and &quot;finish&quot; events
  (def label-up (bind &quot;//label[@id='name-input-label']/span&quot;
                      {:effect :color :end &quot;#53607b&quot; :time 200}
                      {:effect :slide :up 40 :time 200}))
  (event/listen-once label-up
                     &quot;finish&quot;
                     #(js/alert &quot;Animation finished.&quot;))
  (start label-up))</pre></td></tr><tr><td class="docs"><p>Source of unique animation ids.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:doc 
       :private true}
  animation-id (atom 0))</pre></td></tr><tr><td class="docs"><p>Data structure which supports running animations
  sequentially which have been started by the play and play-animation
  functions.</p>
</td><td class="codes"><pre class="brush: clojure">(def ^{:doc 
       :private true}
  animation-queue (atom {:runner nil :running nil :next []}))</pre></td></tr><tr><td class="docs"><p>Add an animation to the <code>animation-queue</code>. If no runner is
  currently running animations then assign that job to the calling
  function by setting <code>:runner</code> to the passed <code>id</code> and putting the
  first animation to run under <code>:running</code>.</p>

<p>  If a runner is already running then add this animation to the
  vector under <code>:next</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- add-to-queue
  [queue id animations]
  (let [new-next (conj (:next queue) animations)]
    (if (:runner queue)
      (assoc queue :next new-next)
      (assoc queue
        :runner id
        :running (first new-next)
        :next (vec (rest new-next))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment

  (add-to-queue {:runner nil :running nil :next []} 2 {:e 1 :a 2})
  (add-to-queue {:runner nil :running nil :next [{:e 1 :a 2}]} 2 {:e 3 :a 4})
  (add-to-queue {:runner 3 :running nil :next [{:e 1 :a 2}]} 2 {:e 3 :a 4})
  )</pre></td></tr><tr><td class="docs"><p>Record that the runner with <code>id</code> has finished running the
  animation. If there are more animations to run, move the next
  animation under the running key and remove it from <code>:next</code>. The same
  runner will continue running animations.</p>

<p>  If there are no more animations to run, release the runner from duty
  by setting <code>:runner</code> to nil.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- record-finished-animation
  [queue id]
  (if (empty? (:next queue))
    (assoc queue :runner nil :running nil)
    (assoc queue :running (first (:next queue)) :next (vec (rest (:next queue))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment

  (record-finished-animation {:runner 2, :running [{:e 1, :a 2}], :next []} 2)
  (record-finished-animation {:runner 3, :running nil, :next [{:e 1, :a 2} {:e 3, :a 4}]} 3)
  )</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare play-animations)</pre></td></tr><tr><td class="docs"><p>This function is called when the runner with <code>id</code> has finished
  running an animation. After updating the queue, if this runner is
  still the designated runner, then start running the next
  animation. If the animation which has completed has an associated
  <code>:after</code> function, run it.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- animation-finished
  [id {after :after}]
  (let [new-queue (swap! animation-queue record-finished-animation id)]
    (when after (after))
    (when (= (:runner new-queue) id)
      (play-animations id new-queue))))</pre></td></tr><tr><td class="docs"><p>Create the animation to run.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- make-animation
  [{:keys [element animation]}]
  (cond element (bind element animation)
        (fn? animation) (animation)
        :else animation))</pre></td></tr><tr><td class="docs"><p>Called by a function which has been assigned the task of running
  animations until there are no more to run. <code>id</code> is the runner
  id. <code>queue</code> is the value of animation-queue after it was last
  updated. Runs any <code>:before</code> function then runs the
  animation. Arranges for <code>animation-finished</code> to be called when the
  animation is complete.</p>

<p>  Implementation note: The delay is a hack to get around the fact that
  the <code>finish</code> event fires just before the animation has completed. The
  100 ms delay gives the finished animation just enough time to
  complete before the next animation is started.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- play-animations
  [id queue]
  (let [animation-map (:running queue)
        animation (make-animation animation-map)]
    (event/listen-once animation
                       &quot;finish&quot;
                       (fn [] (.start (goog.async.Delay. #(animation-finished id animation-map)) 100)))
    (when-let [before (:before animation-map)]
      (before))
    (start animation)))</pre></td></tr><tr><td class="docs"><p>Accepts an element and an animation and ensures that this animation
  will be run after all other animations that have been started by
  this function or by <code>play-animation</code>. An optional map may also be
  passed which may contain the keys <code>:before</code> and <code>:after</code>. Use the <code>:before</code>
  key to provide a function which will be called just before
  the animation starts. Use the <code>:after</code> key to provide a function
  which will be called after the aniamtion is finished.</p>

<p>  The <code>serial</code> function allows you to create animations which run in
  sequence. The <code>start</code> function will run these animations. If <code>start</code>
  is called to run an animation before a previous call to <code>start</code> has
  completed, the animations can conflict. This function should be used
  instead of <code>start</code> when you need to ensure that animations do not
  overlap.</p>
</td><td class="codes"><pre class="brush: clojure">(defn play
  ([element animation]
     (play element animation {}))
  ([element animation {:keys [name after before]}]
     (let [id (swap! animation-id inc)
           animation {:name name :id id :element element :animation animation :before before :after after}
           queue (swap! animation-queue add-to-queue id animation)]
       (when (= (:runner queue) id)
         (play-animations id queue)))))</pre></td></tr><tr><td class="docs"><p>Accepts an animation and an optional map and ensures that this
  animation will be run after all other animations that have been
  started by this function or by <code>play</code>. See documentation for <code>play</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn play-animation
  ([animation]
     (play-animation animation {}))
  ([animation opts]
     (play nil animation opts)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.browser.history" name="one.browser.history"><h1 class="project-name">one.browser.history</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Supports working with <a href="http://closure-library.googlecode.com/svn/docs/namespace_goog_history.html">Google Closure's history management object</a>.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.browser.history
  (:require [clojure.browser.event :as event]
            [goog.History :as history]
            [goog.history.Html5History :as history5]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type goog.History
  
  event/EventType
  (event-types [this]
    (into {}
          (map
           (fn [[k v]]
             [(keyword (. k (toLowerCase)))
              v])
           (js-&gt;clj goog.history.EventType)))))</pre></td></tr><tr><td class="docs"><p>Create a new history object in user visible mode. This allows users
  to, for example, hit the browser's back button without leaving the
  current page. The current history state is shown in the browser
  address bar as a document location fragment (the portion of the URL
  after the '#'). These addresses can be bookmarked, copied and pasted
  into another browser, and modified directly by the user like any
  other URL.</p>

<p>  Any changes to the location hash will call the passed callback
  function.</p>
</td><td class="codes"><pre class="brush: clojure">(defn history
  [callback]
  (let [h (if (history5/isSupported)
            (goog.history.Html5History.)
            (goog.History.))]
    (do (event/listen h &quot;navigate&quot;
                      (fn [e]
                        (callback {:token (keyword (.-token e))
                                   :type (.-type e)
                                   :navigation? (.-isNavigation e)})))
        (.setEnabled h true)
        h)))</pre></td></tr><tr><td class="docs"><p>Sets the <code>history</code> state. The URL fragment will be set to the
  provided token.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-token
  [history token]
  (.setToken history (name token)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.browser.remote" name="one.browser.remote"><h1 class="project-name">one.browser.remote</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Make network requests.</p>

<p>  Adapted from Bobby Calderwood's Trail framework:
  <a href="https://github.com/bobby/trail">https://github.com/bobby/trail</a></p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.browser.remote
  (:require [cljs.reader :as reader]
            [clojure.browser.net :as net]
            [clojure.browser.event :as event]
            [goog.net.XhrManager :as manager]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private responders (atom {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- add-responders [id success error]
  (when (or success error)
    (swap! responders assoc id {:success success :error error})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-type goog.net.XhrManager

  event/EventType
  (event-types [this]
    (into {}
          (map
           (fn [[k v]]
             [(keyword (. k (toLowerCase)))
              v])
           (js-&gt;clj goog.net.EventType)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private
  *xhr-manager*
  (goog.net.XhrManager. nil
                        nil
                        nil
                        0
                        5000))</pre></td></tr><tr><td class="docs"><p>Asynchronously make a network request for the resource at url. If
  provided via the <code>:on-success</code> and <code>:on-error</code> keyword arguments, the
  appropriate one of <code>on-success</code> or <code>on-error</code> will be called on
  completion. They will be passed a map containing the keys <code>:id</code>,
  <code>:body</code>, <code>:status</code>, and <code>:event</code>. The entry for <code>:event</code> contains an
  instance of the <code>goog.net.XhrManager.Event</code>.</p>

<p>  Other allowable keyword arguments are <code>:method</code>, <code>:content</code>, <code>:headers</code>,
  <code>:priority</code>, and <code>:retries</code>. <code>:method</code> defaults to "GET" and <code>:retries</code>
  defaults to <code>0</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn request
  [id url &amp; {:keys [method content headers priority retries on-success
                    on-error]
             :or   {method   &quot;GET&quot;
                    retries  0}}]
  (try
    (add-responders id on-success on-error)
    (.send *xhr-manager*
           id
           url
           method
           content
           headers
           priority
           ;; This next one is a callback, and we could use it to get
           ;; rid of the atom and figure out success/failure ourselves
           nil
           retries)
    (catch js/Error e
      nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- response-success [e]
  (when-let [{success :success} (get @responders (:id e))]
    (success e)
    (swap! responders dissoc (:id e))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- response-error [e]
  (when-let [{error :error} (get @responders (:id e))]
    (error e)
    (swap! responders dissoc (:id e))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- response-received
  [f e]
  (f {:id     (.-id e)
      :body   (. e/xhrIo (getResponseText))
      :status (. e/xhrIo (getStatus))
      :event  e}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(event/listen *xhr-manager* &quot;success&quot; (partial response-received response-success))
(event/listen *xhr-manager* &quot;error&quot;   (partial response-received response-error))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.color" name="one.color"><h1 class="project-name">one.color</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provide support for working with colors. Wraps Google
  Closure's color support.  The <code>goog.color</code> namespace provides support for
  additional color formats.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.color
  (:require [one.core :as core]
            [goog.string :as gstring]
            [goog.style :as style]
            [goog.color :as gcolor]
            [goog.color.alpha :as alpha]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IColor
  (rgb [this] &quot;Returns a vector `[r g b]`.&quot;)
  (rgba [this] &quot;Returns a vector `[r g b a]`.&quot;)
  (hex [this] &quot;Returns a hex string for this color.&quot;)
  (hex-rgba [this] &quot;Returns a hex rgba string for this color.&quot;)
  (alpha [this] &quot;Returns the alpha for this color, a number in the range `[0 1]`.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defrecord Color [r g b a]
  IColor
  (rgb [_] [r g b])
  (rgba [_] [r g b a])
  (hex [_]
    (gcolor/rgbArrayToHex (array r g b)))
  (hex-rgba [_]
    (alpha/rgbaArrayToHex (array r g b a)))
  (alpha [_] a))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- make-color
  ([r g b]
     (make-color r g b 1))
  ([r g b a]
     (Color. r g b a)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment ;; Color examples
  (def red (make-color 200 0 0))
  (rgb red)
  (rgba red)
  (hex red)
  (hex-rgba red)
  (alpha red))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol IColorSource
  (color [this] &quot;Get the color from the passed object. Return a `Color` object.&quot;)
  (bg-color [this] &quot;Get the background color from the passed
  object. Returns a `Color` object.&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol IColorSource

  nil
  (color [this] (make-color 0 0 0))
  (bg-color [this] (make-color 0 0 0))

  Color
  (color [this] this)
  (bg-color [this] this)

  cljs.core.Vector
  (color [this] (apply make-color this))
  (bg-color [this] (apply make-color this))

  js/Array
  (color [this] (apply make-color (js-&gt;clj this)))
  (bg-color [this] (apply make-color (js-&gt;clj this)))

  js/String
  (color [this]
    (color (js-&gt;clj (cond (gstring/startsWith this &quot;#&quot;)
                          (cond (= (count this) 7) (gcolor/hexToRgb this)
                                (= (count this) 9) (alpha/hexToRgba this))
                          
                          (gstring/startsWith this &quot;rgba(&quot;)
                          (alpha/parse this)

                          (gstring/startsWith this &quot;rgb(&quot;) (gcolor/parseRgb this))
                    :keywordize-keys true)))
  (bg-color [this] (color this))
  
  cljs.core.ObjMap
  (color [this] (color (:hex this)))
  (bg-color [this] (color this))
  
  js/Element
  (color [this]
    (color (js-&gt;clj (gcolor/parse (core/get-style this &quot;color&quot;))
                    :keywordize-keys true)))
  (bg-color [this]
    (color (js-&gt;clj (let [c (style/getBackgroundColor this)]
                      (try
                        (gcolor/parse c)
                        (catch js/Error e (alpha/parse c))))
                    :keywordize-keys true))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.core" name="one.core"><h1 class="project-name">one.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Core ClojureScript One library.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.core
  (:require [goog.style :as style]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol Startable
  (start [this]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol Disposable
  (dispose [this]))</pre></td></tr><tr><td class="docs"><p>Use alternate strategies to get around the fact that
  <code>goog.style.getComputedStyle</code> returns an empty string for IE8 and
  below.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-style
  [element style]
  (some #(let [v (%)] (when (not= &quot;&quot; v) v))
        [#(style/getComputedStyle element style)
         #(style/getStyle element style)
         #(aget (.-currentStyle element) style)
         #(throw (js/Error. (str &quot;Could not retrieve value for style &quot; style)))]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.dispatch" name="one.dispatch"><h1 class="project-name">one.dispatch</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Event dispatching.</p>

<p>  Provides a way for code to react to events. Terminology:</p>

<ul>
<li><p>event-id: Identifies a class of events. Can be any Clojure value.</p></li>
<li><p>event-data: Parameterizes a particular event. Can be any Clojure
value.</p></li>
<li><p>reactor: A function that is invoked in response to an event
occurring.</p></li>
<li><p>reaction: A relationship between a set of events and a reactor.</p></li>
<li><p>event-pred: A function which takes an event ID and returns true or
false.</p>

<p>Reactors are associated with events via <code>react-to</code>. When events are
fired with an <code>event-id</code> and optional <code>event-data</code>, any reactors whose
<code>event-pred</code> returns true for the <code>event-id</code> are invoked.</p></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.dispatch)</pre></td></tr><tr><td class="docs"><p>Stores the current reactions.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  reactions (atom {}))</pre></td></tr><tr><td class="docs"><p>Cause the specified reactor to be invoked whenever an event that
  satisfies <code>event-pred</code> is fired. reactor is a function that accepts
  two arguments: <code>event-id</code> and <code>event-data</code>.</p>

<p>  Returns the reaction.</p>

<p>  The reactor will continue to be invoked until one of two things
  happens:</p>

<ol>
<li><p><code>delete-reaction</code> is called on this reaction.</p></li>
<li><p>The reaction occurs <code>max-count</code> times. If <code>max-count</code> is not
  specified, the reaction will continue to be invoked until deleted.</p>

<p>If <code>max-count</code> is specified, <code>delete-reaction</code> will be called
automatically when the reaction has occurred the specified number of
times.</p></li>
</ol>
</td><td class="codes"><pre class="brush: clojure">(defn react-to
  ([event-pred reactor]
     (react-to nil event-pred reactor))
  ([max-count event-pred reactor]
     (let [reaction {:max-count max-count
                     :event-pred event-pred
                     :reactor reactor}]
       (swap! reactions assoc reaction 0)
       reaction)))</pre></td></tr><tr><td class="docs"><p>Delete a reaction. After calling this function, the specified
  reaction will no longer be invoked.</p>
</td><td class="codes"><pre class="brush: clojure">(defn delete-reaction
  [reaction]
  (swap! reactions dissoc reaction))</pre></td></tr><tr><td class="docs"><p>Raise an event to any reactors whose event-pred returns true for
  <code>event-id</code>. The <code>event-id</code> and <code>event-data</code>, if specified, are passed to
  the reactor.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fire
  ([event-id]
     (fire event-id nil))
  ([event-id event-data]
     (let [matching-reactions (filter (fn [[{event-pred :event-pred} run-count]]
                                        (event-pred event-id))
                                      @reactions)]
       (doseq [[reaction run-count] matching-reactions]
         (let [{:keys [max-count reactor]} reaction
               run-count (inc run-count)]
           (reactor event-id event-data)
           (if (and max-count
                    (&lt;= max-count run-count))
             (delete-reaction reaction)
             (swap! reactions assoc reaction run-count)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment

  (require '[cljs.repl :as repl])
  (require '[cljs.repl.rhino :as rhino])
  (repl/repl (rhino/repl-env))

  (do
    (let [recorded-reactions (atom [])
          reaction (react-to #{:do-something} #(swap! recorded-reactions conj [%1 %2]))]
      ;; Did we get a reaction back?
      (assert reaction)
      (fire :do-something)
      ;; Did the reactor catch the event?
      (assert (= [[:do-something nil]] @recorded-reactions))
      (fire :do-something)
      ;; Did the reactor catch the event a second time?
      (assert (= [[:do-something nil] [:do-something nil]] @recorded-reactions))
      (fire :something-else)
      ;; Did we ignore events we're not reacting to?
      (assert (= [[:do-something nil] [:do-something nil]] @recorded-reactions))
      (reset! recorded-reactions [])
      (fire :do-something 17)
      ;; Does event data arrive intact?
      (assert (= [[:do-something 17]] @recorded-reactions))
      (reset! recorded-reactions [])
      (delete-reaction reaction)
      (fire :do-something 17)
      ;; Does deleting a reaction cause us to stop reacting?
      (assert (= [] @recorded-reactions)))
    (let [recorded-reactions (atom #{})
          reaction-once (react-to 1 #{:do-something}
                                  #(swap! recorded-reactions conj [1 %1 %2]))
          reaction-twice (react-to 2 #{:do-something}
                                   #(swap! recorded-reactions conj [2 %1 %2]))]
      (fire :do-something 1)
      ;; Did both reactions react?
      (assert (= #{[1 :do-something 1] [2 :do-something 1]} @recorded-reactions))
      (fire :do-something 2)
      ;; Did only the second reaction react?
      (assert (= #{[1 :do-something 1] [2 :do-something 1] [2 :do-something 2]}
                 @recorded-reactions))
      (fire :do-something 3)
      ;; Did nothing change?
      (assert (= #{[1 :do-something 1] [2 :do-something 1] [2 :do-something 2]}
                 @recorded-reactions)))
    true
    )
  )</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#one.logging" name="one.logging"><h1 class="project-name">one.logging</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Basic wrapper around <a href="http://closure-library.googlecode.com/svn/docs/class_goog_debug_Logger.html">Google Closure's logging API</a>.</p>

<p>  This library can be improved to support more of the features
  provided by Google Closure's logging.</p>
</td><td class="codes"><pre class="brush: clojure">(ns 
  one.logging
  (:require [goog.debug.Console :as console]
            [goog.debug.FancyWindow :as fancy]
            [goog.debug.Logger :as logger]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol ILogViewer
  (start-display [this] &quot;Start displaying log messages in this viewer.&quot;)
  (stop-display [this] &quot;Stop displaying log messages in this viewer.&quot;))</pre></td></tr><tr><td class="docs"><p>Maps log level keywords to <code>goog.debug.Logger.Levels</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(def 
  levels {:severe goog.debug.Logger.Level.SEVERE
          :warning goog.debug.Logger.Level.WARNING
          :info goog.debug.Logger.Level.INFO
          :config goog.debug.Logger.Level.CONFIG
          :fine goog.debug.Logger.Level.FINE
          :finer goog.debug.Logger.Level.FINER
          :finest goog.debug.Logger.Level.FINEST})</pre></td></tr><tr><td class="docs"><p>Given a name, return an existing logger if one exists or create a
  new logger.</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-logger
  [name]
  (goog.debug.Logger/getLogger name))</pre></td></tr><tr><td class="docs"><p>Given a logger and a message, write the message to the log with a
  logging level of <code>severe</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn severe
  [logger s] (.severe logger s))</pre></td></tr><tr><td class="docs"><p>Given a logger and a message, write the message to the log with a
  logging level of <code>warning</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn warning
  [logger s] (.warning logger s))</pre></td></tr><tr><td class="docs"><p>Given a logger and a message, write the message to the log with a
  logging level of <code>info</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn info
  [logger s] (.info logger s))</pre></td></tr><tr><td class="docs"><p>Given a logger and a message, write the message to the log with a
  logging level of <code>config</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn config
  [logger s] (.config logger s))</pre></td></tr><tr><td class="docs"><p>Given a logger and a message, write the message to the log with a
  logging level of <code>fine</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fine
  [logger s] (.fine logger s))</pre></td></tr><tr><td class="docs"><p>Given a logger and a message, write the message to the log with a
  logging level of <code>finer</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn finer
  [logger s] (.finer logger s))</pre></td></tr><tr><td class="docs"><p>Given a logger and a message, write the message to the log with a
  logging level of <code>finest</code>.</p>
</td><td class="codes"><pre class="brush: clojure">(defn finest
  [logger s] (.finest logger s))</pre></td></tr><tr><td class="docs"><p>Set the logging level of <code>logger</code> to <code>level</code>.</p>

<p>  The <code>level</code> argument must be a keyword.</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-level
  [logger level]
  (.setLevel logger (get levels level goog.debug.Logger.Level.INFO)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol ILogViewer
  
  goog.debug.Console
  (start-display [this]
    (.setCapturing this true))
  (stop-display [this]
    (.setCapturing this false))
  
  goog.debug.FancyWindow
  (start-display [this]
    (doto this
      (.setEnabled true)
      (.init ())))
  (stop-display [this]
    (.setCapturing this false)))</pre></td></tr><tr><td class="docs"><p>Returns a log viewer which will direct log messages to the
  browser's <code>console</code> window. Use the <code>start-display</code> and
  <code>stop-display</code> functions to start and stop printing log messages to
  the console.</p>
</td><td class="codes"><pre class="brush: clojure">(defn console-output
  []
  (goog.debug.Console.))</pre></td></tr><tr><td class="docs"><p>Returns a log viewer which will open a fancy logging window and
  direct log messages to it. Use the <code>start-display</code> and
  <code>stop-display</code> functions to start and stop printing log messages in
  this window.</p>
</td><td class="codes"><pre class="brush: clojure">(defn fancy-output
  [name]
  (goog.debug.FancyWindow. name))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/fogus/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
       SyntaxHighlighter.all()</script></body></html>